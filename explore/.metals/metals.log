2022.10.07 11:26:55 INFO  tracing is disabled for protocol LSP, to enable tracing of incoming and outgoing JSON messages create an empty file at /Users/georgy/Desktop/study/vii-semester/diploma/explore/.metals/lsp.trace.json or /Users/georgy/Library/Caches/org.scalameta.metals/lsp.trace.json
2022.10.07 11:26:56 INFO  logging to file /Users/georgy/Desktop/study/vii-semester/diploma/explore/.metals/metals.log
2022.10.07 11:26:56 INFO  Started: Metals version 0.11.9 in workspace '/Users/georgy/Desktop/study/vii-semester/diploma/explore' for client Visual Studio Code 1.71.2.
2022.10.07 11:26:58 INFO  time: initialize in 2.56s
2022.10.07 11:27:01 WARN  Build server is not auto-connectable.
2022.10.07 11:27:01 WARN  no build target for: /Users/georgy/Desktop/study/vii-semester/diploma/explore/src/main/scala/navigate/Main.scala
2022.10.07 11:27:04 INFO  no build target found for /Users/georgy/Desktop/study/vii-semester/diploma/explore/src/main/scala/navigate/Main.scala. Using presentation compiler with project's scala-library version: 3.2.0
2022.10.07 11:27:07 INFO  time: code lens generation in 5.04s
2022.10.07 11:28:00 WARN  no build target for: /Users/georgy/Desktop/study/vii-semester/diploma/explore/src/main/scala/navigate/Main.scala
2022.10.07 11:28:11 WARN  no build target for: /Users/georgy/Desktop/study/vii-semester/diploma/explore/src/main/scala/navigate/Main.scala
2022.10.07 11:29:22 WARN  no build target for: /Users/georgy/Desktop/study/vii-semester/diploma/explore/src/main/scala/navigate/Main.scala
2022.10.07 11:29:25 WARN  no build target for: /Users/georgy/Desktop/study/vii-semester/diploma/explore/src/main/scala/navigate/Main.scala
2022.10.07 11:29:31 WARN  no build target for: /Users/georgy/Desktop/study/vii-semester/diploma/explore/src/main/scala/navigate/Main.scala
2022.10.07 11:29:46 WARN  no build target for: /Users/georgy/Desktop/study/vii-semester/diploma/explore/src/main/scala/navigate/Main.scala
2022.10.07 11:29:49 WARN  no build target for: /Users/georgy/Desktop/study/vii-semester/diploma/explore/src/main/scala/navigate/Main.scala
2022.10.07 11:30:19 WARN  no build target for: /Users/georgy/Desktop/study/vii-semester/diploma/explore/src/main/scala/navigate/Main.scala
2022.10.07 11:30:27 WARN  no build target for: /Users/georgy/Desktop/study/vii-semester/diploma/explore/src/main/scala/navigate/Main.scala
2022.10.07 11:30:35 WARN  no build target for: /Users/georgy/Desktop/study/vii-semester/diploma/explore/src/main/scala/navigate/Main.scala
2022.10.07 11:30:37 WARN  no build target for: /Users/georgy/Desktop/study/vii-semester/diploma/explore/src/main/scala/navigate/Main.scala
2022.10.07 11:30:39 WARN  no build target for: /Users/georgy/Desktop/study/vii-semester/diploma/explore/src/main/scala/navigate/Main.scala
2022.10.07 11:30:43 WARN  no build target for: /Users/georgy/Desktop/study/vii-semester/diploma/explore/src/main/scala/navigate/Main.scala
2022.10.07 11:30:49 WARN  no build target for: /Users/georgy/Desktop/study/vii-semester/diploma/explore/src/main/scala/navigate/Main.scala
2022.10.07 11:30:52 WARN  no build target for: /Users/georgy/Desktop/study/vii-semester/diploma/explore/src/main/scala/navigate/Main.scala
2022.10.07 11:30:58 WARN  no build target for: /Users/georgy/Desktop/study/vii-semester/diploma/explore/src/main/scala/navigate/Main.scala
2022.10.07 11:31:00 WARN  no build target for: /Users/georgy/Desktop/study/vii-semester/diploma/explore/src/main/scala/navigate/Main.scala
2022.10.07 11:31:04 WARN  no build target for: /Users/georgy/Desktop/study/vii-semester/diploma/explore/src/main/scala/navigate/Main.scala
2022.10.07 11:31:05 WARN  no build target for: /Users/georgy/Desktop/study/vii-semester/diploma/explore/src/main/scala/navigate/Main.scala
2022.10.07 11:31:07 WARN  no build target for: /Users/georgy/Desktop/study/vii-semester/diploma/explore/src/main/scala/navigate/Main.scala
2022.10.07 11:31:12 WARN  no build target for: /Users/georgy/Desktop/study/vii-semester/diploma/explore/src/main/scala/navigate/Main.scala
2022.10.07 11:31:14 WARN  no build target for: /Users/georgy/Desktop/study/vii-semester/diploma/explore/src/main/scala/navigate/Main.scala
2022.10.07 11:31:15 WARN  no build target for: /Users/georgy/Desktop/study/vii-semester/diploma/explore/src/main/scala/navigate/Main.scala
2022.10.07 11:31:18 WARN  no build target for: /Users/georgy/Desktop/study/vii-semester/diploma/explore/src/main/scala/navigate/Main.scala
2022.10.07 11:31:19 WARN  no build target for: /Users/georgy/Desktop/study/vii-semester/diploma/explore/src/main/scala/navigate/Main.scala
2022.10.07 11:31:34 WARN  no build target for: /Users/georgy/Desktop/study/vii-semester/diploma/explore/src/main/scala/navigate/Graph.scala
2022.10.07 11:31:51 WARN  no build target for: /Users/georgy/Desktop/study/vii-semester/diploma/explore/src/main/scala/navigate/Main.scala
2022.10.07 11:31:57 WARN  no build target for: /Users/georgy/Desktop/study/vii-semester/diploma/explore/src/main/scala/navigate/Main.scala
окт. 07, 2022 11:31:58 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didOpen",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///Users/georgy/Library/Caches/Coursier/arc/https/github.com/AdoptOpenJDK/openjdk11-binaries/releases/download/jdk-11%25252B28/OpenJDK11-jdk_x64_mac_hotspot_11_28.tar.gz/jdk-11%2B28/Contents/Home/lib/src.zip%21/java.base/java/lang/System.java",
      "languageId": "java",
      "version": 1,
      "text": "/*\n * Copyright (c) 1994, 2018, Oracle and/or its affiliates. All rights reserved.\n * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n *\n * This code is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License version 2 only, as\n * published by the Free Software Foundation.  Oracle designates this\n * particular file as subject to the \"Classpath\" exception as provided\n * by Oracle in the LICENSE file that accompanied this code.\n *\n * This code is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n * version 2 for more details (a copy is included in the LICENSE file that\n * accompanied this code).\n *\n * You should have received a copy of the GNU General Public License version\n * 2 along with this work; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n * or visit www.oracle.com if you need additional information or have any\n * questions.\n */\npackage java.lang;\n\nimport java.io.BufferedInputStream;\nimport java.io.BufferedOutputStream;\nimport java.io.Console;\nimport java.io.FileDescriptor;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintStream;\nimport java.io.UnsupportedEncodingException;\nimport java.lang.annotation.Annotation;\nimport java.lang.module.ModuleDescriptor;\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Executable;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Modifier;\nimport java.net.URI;\nimport java.nio.charset.CharacterCodingException;\nimport java.security.AccessControlContext;\nimport java.security.ProtectionDomain;\nimport java.security.AccessController;\nimport java.security.PrivilegedAction;\nimport java.nio.channels.Channel;\nimport java.nio.channels.spi.SelectorProvider;\nimport java.nio.charset.Charset;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.Properties;\nimport java.util.PropertyPermission;\nimport java.util.ResourceBundle;\nimport java.util.function.Supplier;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.stream.Stream;\n\nimport jdk.internal.util.StaticProperty;\nimport jdk.internal.module.ModuleBootstrap;\nimport jdk.internal.module.ServicesCatalog;\nimport jdk.internal.reflect.CallerSensitive;\nimport jdk.internal.reflect.Reflection;\nimport jdk.internal.HotSpotIntrinsicCandidate;\nimport jdk.internal.misc.JavaLangAccess;\nimport jdk.internal.misc.SharedSecrets;\nimport jdk.internal.misc.VM;\nimport jdk.internal.logger.LoggerFinderLoader;\nimport jdk.internal.logger.LazyLoggers;\nimport jdk.internal.logger.LocalizedLoggerWrapper;\nimport sun.reflect.annotation.AnnotationType;\nimport sun.nio.ch.Interruptible;\nimport sun.security.util.SecurityConstants;\n\n/**\n * The {@code System} class contains several useful class fields\n * and methods. It cannot be instantiated.\n *\n * Among the facilities provided by the {@code System} class\n * are standard input, standard output, and error output streams;\n * access to externally defined properties and environment\n * variables; a means of loading files and libraries; and a utility\n * method for quickly copying a portion of an array.\n *\n * @since   1.0\n */\npublic final class System {\n    /* Register the natives via the static initializer.\n     *\n     * VM will invoke the initializeSystemClass method to complete\n     * the initialization for this class separated from clinit.\n     * Note that to use properties set by the VM, see the constraints\n     * described in the initializeSystemClass method.\n     */\n    private static native void registerNatives();\n    static {\n        registerNatives();\n    }\n\n    /** Don\u0027t let anyone instantiate this class */\n    private System() {\n    }\n\n    /**\n     * The \"standard\" input stream. This stream is already\n     * open and ready to supply input data. Typically this stream\n     * corresponds to keyboard input or another input source specified by\n     * the host environment or user.\n     */\n    public static final InputStream in \u003d null;\n\n    /**\n     * The \"standard\" output stream. This stream is already\n     * open and ready to accept output data. Typically this stream\n     * corresponds to display output or another output destination\n     * specified by the host environment or user.\n     * \u003cp\u003e\n     * For simple stand-alone Java applications, a typical way to write\n     * a line of output data is:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     *     System.out.println(data)\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     * \u003cp\u003e\n     * See the {@code println} methods in class {@code PrintStream}.\n     *\n     * @see     java.io.PrintStream#println()\n     * @see     java.io.PrintStream#println(boolean)\n     * @see     java.io.PrintStream#println(char)\n     * @see     java.io.PrintStream#println(char[])\n     * @see     java.io.PrintStream#println(double)\n     * @see     java.io.PrintStream#println(float)\n     * @see     java.io.PrintStream#println(int)\n     * @see     java.io.PrintStream#println(long)\n     * @see     java.io.PrintStream#println(java.lang.Object)\n     * @see     java.io.PrintStream#println(java.lang.String)\n     */\n    public static final PrintStream out \u003d null;\n\n    /**\n     * The \"standard\" error output stream. This stream is already\n     * open and ready to accept output data.\n     * \u003cp\u003e\n     * Typically this stream corresponds to display output or another\n     * output destination specified by the host environment or user. By\n     * convention, this output stream is used to display error messages\n     * or other information that should come to the immediate attention\n     * of a user even if the principal output stream, the value of the\n     * variable {@code out}, has been redirected to a file or other\n     * destination that is typically not continuously monitored.\n     */\n    public static final PrintStream err \u003d null;\n\n    /* The security manager for the system.\n     */\n    private static volatile SecurityManager security;\n\n    /**\n     * Reassigns the \"standard\" input stream.\n     *\n     * First, if there is a security manager, its {@code checkPermission}\n     * method is called with a {@code RuntimePermission(\"setIO\")} permission\n     *  to see if it\u0027s ok to reassign the \"standard\" input stream.\n     *\n     * @param in the new standard input stream.\n     *\n     * @throws SecurityException\n     *        if a security manager exists and its\n     *        {@code checkPermission} method doesn\u0027t allow\n     *        reassigning of the standard input stream.\n     *\n     * @see SecurityManager#checkPermission\n     * @see java.lang.RuntimePermission\n     *\n     * @since   1.1\n     */\n    public static void setIn(InputStream in) {\n        checkIO();\n        setIn0(in);\n    }\n\n    /**\n     * Reassigns the \"standard\" output stream.\n     *\n     * First, if there is a security manager, its {@code checkPermission}\n     * method is called with a {@code RuntimePermission(\"setIO\")} permission\n     *  to see if it\u0027s ok to reassign the \"standard\" output stream.\n     *\n     * @param out the new standard output stream\n     *\n     * @throws SecurityException\n     *        if a security manager exists and its\n     *        {@code checkPermission} method doesn\u0027t allow\n     *        reassigning of the standard output stream.\n     *\n     * @see SecurityManager#checkPermission\n     * @see java.lang.RuntimePermission\n     *\n     * @since   1.1\n     */\n    public static void setOut(PrintStream out) {\n        checkIO();\n        setOut0(out);\n    }\n\n    /**\n     * Reassigns the \"standard\" error output stream.\n     *\n     * First, if there is a security manager, its {@code checkPermission}\n     * method is called with a {@code RuntimePermission(\"setIO\")} permission\n     *  to see if it\u0027s ok to reassign the \"standard\" error output stream.\n     *\n     * @param err the new standard error output stream.\n     *\n     * @throws SecurityException\n     *        if a security manager exists and its\n     *        {@code checkPermission} method doesn\u0027t allow\n     *        reassigning of the standard error output stream.\n     *\n     * @see SecurityManager#checkPermission\n     * @see java.lang.RuntimePermission\n     *\n     * @since   1.1\n     */\n    public static void setErr(PrintStream err) {\n        checkIO();\n        setErr0(err);\n    }\n\n    private static volatile Console cons;\n    /**\n     * Returns the unique {@link java.io.Console Console} object associated\n     * with the current Java virtual machine, if any.\n     *\n     * @return  The system console, if any, otherwise {@code null}.\n     *\n     * @since   1.6\n     */\n     public static Console console() {\n         Console c;\n         if ((c \u003d cons) \u003d\u003d null) {\n             synchronized (System.class) {\n                 if ((c \u003d cons) \u003d\u003d null) {\n                     cons \u003d c \u003d SharedSecrets.getJavaIOAccess().console();\n                 }\n             }\n         }\n         return c;\n     }\n\n    /**\n     * Returns the channel inherited from the entity that created this\n     * Java virtual machine.\n     *\n     * This method returns the channel obtained by invoking the\n     * {@link java.nio.channels.spi.SelectorProvider#inheritedChannel\n     * inheritedChannel} method of the system-wide default\n     * {@link java.nio.channels.spi.SelectorProvider} object.\n     *\n     * \u003cp\u003e In addition to the network-oriented channels described in\n     * {@link java.nio.channels.spi.SelectorProvider#inheritedChannel\n     * inheritedChannel}, this method may return other kinds of\n     * channels in the future.\n     *\n     * @return  The inherited channel, if any, otherwise {@code null}.\n     *\n     * @throws  IOException\n     *          If an I/O error occurs\n     *\n     * @throws  SecurityException\n     *          If a security manager is present and it does not\n     *          permit access to the channel.\n     *\n     * @since 1.5\n     */\n    public static Channel inheritedChannel() throws IOException {\n        return SelectorProvider.provider().inheritedChannel();\n    }\n\n    private static void checkIO() {\n        SecurityManager sm \u003d getSecurityManager();\n        if (sm !\u003d null) {\n            sm.checkPermission(new RuntimePermission(\"setIO\"));\n        }\n    }\n\n    private static native void setIn0(InputStream in);\n    private static native void setOut0(PrintStream out);\n    private static native void setErr0(PrintStream err);\n\n    /**\n     * Sets the System security.\n     *\n     * If there is a security manager already installed, this method first\n     * calls the security manager\u0027s {@code checkPermission} method\n     * with a {@code RuntimePermission(\"setSecurityManager\")}\n     * permission to ensure it\u0027s ok to replace the existing\n     * security manager.\n     * This may result in throwing a {@code SecurityException}.\n     *\n     * \u003cp\u003e Otherwise, the argument is established as the current\n     * security manager. If the argument is {@code null} and no\n     * security manager has been established, then no action is taken and\n     * the method simply returns.\n     *\n     * @param      s   the security manager.\n     * @throws     SecurityException  if the security manager has already\n     *             been set and its {@code checkPermission} method\n     *             doesn\u0027t allow it to be replaced.\n     * @see #getSecurityManager\n     * @see SecurityManager#checkPermission\n     * @see java.lang.RuntimePermission\n     */\n    public static void setSecurityManager(final SecurityManager s) {\n        if (security \u003d\u003d null) {\n            // ensure image reader is initialized\n            Object.class.getResource(\"java/lang/ANY\");\n        }\n        if (s !\u003d null) {\n            try {\n                s.checkPackageAccess(\"java.lang\");\n            } catch (Exception e) {\n                // no-op\n            }\n        }\n        setSecurityManager0(s);\n    }\n\n    private static synchronized\n    void setSecurityManager0(final SecurityManager s) {\n        SecurityManager sm \u003d getSecurityManager();\n        if (sm !\u003d null) {\n            // ask the currently installed security manager if we\n            // can replace it.\n            sm.checkPermission(new RuntimePermission\n                                     (\"setSecurityManager\"));\n        }\n\n        if ((s !\u003d null) \u0026\u0026 (s.getClass().getClassLoader() !\u003d null)) {\n            // New security manager class is not on bootstrap classpath.\n            // Cause policy to get initialized before we install the new\n            // security manager, in order to prevent infinite loops when\n            // trying to initialize the policy (which usually involves\n            // accessing some security and/or system properties, which in turn\n            // calls the installed security manager\u0027s checkPermission method\n            // which will loop infinitely if there is a non-system class\n            // (in this case: the new security manager class) on the stack).\n            AccessController.doPrivileged(new PrivilegedAction\u003c\u003e() {\n                public Object run() {\n                    s.getClass().getProtectionDomain().implies\n                        (SecurityConstants.ALL_PERMISSION);\n                    return null;\n                }\n            });\n        }\n\n        security \u003d s;\n    }\n\n    /**\n     * Gets the system security interface.\n     *\n     * @return  if a security manager has already been established for the\n     *          current application, then that security manager is returned;\n     *          otherwise, {@code null} is returned.\n     * @see     #setSecurityManager\n     */\n    public static SecurityManager getSecurityManager() {\n        return security;\n    }\n\n    /**\n     * Returns the current time in milliseconds.  Note that\n     * while the unit of time of the return value is a millisecond,\n     * the granularity of the value depends on the underlying\n     * operating system and may be larger.  For example, many\n     * operating systems measure time in units of tens of\n     * milliseconds.\n     *\n     * \u003cp\u003e See the description of the class {@code Date} for\n     * a discussion of slight discrepancies that may arise between\n     * \"computer time\" and coordinated universal time (UTC).\n     *\n     * @return  the difference, measured in milliseconds, between\n     *          the current time and midnight, January 1, 1970 UTC.\n     * @see     java.util.Date\n     */\n    @HotSpotIntrinsicCandidate\n    public static native long currentTimeMillis();\n\n    /**\n     * Returns the current value of the running Java Virtual Machine\u0027s\n     * high-resolution time source, in nanoseconds.\n     *\n     * This method can only be used to measure elapsed time and is\n     * not related to any other notion of system or wall-clock time.\n     * The value returned represents nanoseconds since some fixed but\n     * arbitrary \u003ci\u003eorigin\u003c/i\u003e time (perhaps in the future, so values\n     * may be negative).  The same origin is used by all invocations of\n     * this method in an instance of a Java virtual machine; other\n     * virtual machine instances are likely to use a different origin.\n     *\n     * \u003cp\u003eThis method provides nanosecond precision, but not necessarily\n     * nanosecond resolution (that is, how frequently the value changes)\n     * - no guarantees are made except that the resolution is at least as\n     * good as that of {@link #currentTimeMillis()}.\n     *\n     * \u003cp\u003eDifferences in successive calls that span greater than\n     * approximately 292 years (2\u003csup\u003e63\u003c/sup\u003e nanoseconds) will not\n     * correctly compute elapsed time due to numerical overflow.\n     *\n     * \u003cp\u003eThe values returned by this method become meaningful only when\n     * the difference between two such values, obtained within the same\n     * instance of a Java virtual machine, is computed.\n     *\n     * \u003cp\u003eFor example, to measure how long some code takes to execute:\n     * \u003cpre\u003e {@code\n     * long startTime \u003d System.nanoTime();\n     * // ... the code being measured ...\n     * long elapsedNanos \u003d System.nanoTime() - startTime;}\u003c/pre\u003e\n     *\n     * \u003cp\u003eTo compare elapsed time against a timeout, use \u003cpre\u003e {@code\n     * if (System.nanoTime() - startTime \u003e\u003d timeoutNanos) ...}\u003c/pre\u003e\n     * instead of \u003cpre\u003e {@code\n     * if (System.nanoTime() \u003e\u003d startTime + timeoutNanos) ...}\u003c/pre\u003e\n     * because of the possibility of numerical overflow.\n     *\n     * @return the current value of the running Java Virtual Machine\u0027s\n     *         high-resolution time source, in nanoseconds\n     * @since 1.5\n     */\n    @HotSpotIntrinsicCandidate\n    public static native long nanoTime();\n\n    /**\n     * Copies an array from the specified source array, beginning at the\n     * specified position, to the specified position of the destination array.\n     * A subsequence of array components are copied from the source\n     * array referenced by {@code src} to the destination array\n     * referenced by {@code dest}. The number of components copied is\n     * equal to the {@code length} argument. The components at\n     * positions {@code srcPos} through\n     * {@code srcPos+length-1} in the source array are copied into\n     * positions {@code destPos} through\n     * {@code destPos+length-1}, respectively, of the destination\n     * array.\n     * \u003cp\u003e\n     * If the {@code src} and {@code dest} arguments refer to the\n     * same array object, then the copying is performed as if the\n     * components at positions {@code srcPos} through\n     * {@code srcPos+length-1} were first copied to a temporary\n     * array with {@code length} components and then the contents of\n     * the temporary array were copied into positions\n     * {@code destPos} through {@code destPos+length-1} of the\n     * destination array.\n     * \u003cp\u003e\n     * If {@code dest} is {@code null}, then a\n     * {@code NullPointerException} is thrown.\n     * \u003cp\u003e\n     * If {@code src} is {@code null}, then a\n     * {@code NullPointerException} is thrown and the destination\n     * array is not modified.\n     * \u003cp\u003e\n     * Otherwise, if any of the following is true, an\n     * {@code ArrayStoreException} is thrown and the destination is\n     * not modified:\n     * \u003cul\u003e\n     * \u003cli\u003eThe {@code src} argument refers to an object that is not an\n     *     array.\n     * \u003cli\u003eThe {@code dest} argument refers to an object that is not an\n     *     array.\n     * \u003cli\u003eThe {@code src} argument and {@code dest} argument refer\n     *     to arrays whose component types are different primitive types.\n     * \u003cli\u003eThe {@code src} argument refers to an array with a primitive\n     *    component type and the {@code dest} argument refers to an array\n     *     with a reference component type.\n     * \u003cli\u003eThe {@code src} argument refers to an array with a reference\n     *    component type and the {@code dest} argument refers to an array\n     *     with a primitive component type.\n     * \u003c/ul\u003e\n     * \u003cp\u003e\n     * Otherwise, if any of the following is true, an\n     * {@code IndexOutOfBoundsException} is\n     * thrown and the destination is not modified:\n     * \u003cul\u003e\n     * \u003cli\u003eThe {@code srcPos} argument is negative.\n     * \u003cli\u003eThe {@code destPos} argument is negative.\n     * \u003cli\u003eThe {@code length} argument is negative.\n     * \u003cli\u003e{@code srcPos+length} is greater than\n     *     {@code src.length}, the length of the source array.\n     * \u003cli\u003e{@code destPos+length} is greater than\n     *     {@code dest.length}, the length of the destination array.\n     * \u003c/ul\u003e\n     * \u003cp\u003e\n     * Otherwise, if any actual component of the source array from\n     * position {@code srcPos} through\n     * {@code srcPos+length-1} cannot be converted to the component\n     * type of the destination array by assignment conversion, an\n     * {@code ArrayStoreException} is thrown. In this case, let\n     * \u003cb\u003e\u003ci\u003ek\u003c/i\u003e\u003c/b\u003e be the smallest nonnegative integer less than\n     * length such that {@code src[srcPos+}\u003ci\u003ek\u003c/i\u003e{@code ]}\n     * cannot be converted to the component type of the destination\n     * array; when the exception is thrown, source array components from\n     * positions {@code srcPos} through\n     * {@code srcPos+}\u003ci\u003ek\u003c/i\u003e{@code -1}\n     * will already have been copied to destination array positions\n     * {@code destPos} through\n     * {@code destPos+}\u003ci\u003ek\u003c/I\u003e{@code -1} and no other\n     * positions of the destination array will have been modified.\n     * (Because of the restrictions already itemized, this\n     * paragraph effectively applies only to the situation where both\n     * arrays have component types that are reference types.)\n     *\n     * @param      src      the source array.\n     * @param      srcPos   starting position in the source array.\n     * @param      dest     the destination array.\n     * @param      destPos  starting position in the destination data.\n     * @param      length   the number of array elements to be copied.\n     * @throws     IndexOutOfBoundsException  if copying would cause\n     *             access of data outside array bounds.\n     * @throws     ArrayStoreException  if an element in the {@code src}\n     *             array could not be stored into the {@code dest} array\n     *             because of a type mismatch.\n     * @throws     NullPointerException if either {@code src} or\n     *             {@code dest} is {@code null}.\n     */\n    @HotSpotIntrinsicCandidate\n    public static native void arraycopy(Object src,  int  srcPos,\n                                        Object dest, int destPos,\n                                        int length);\n\n    /**\n     * Returns the same hash code for the given object as\n     * would be returned by the default method hashCode(),\n     * whether or not the given object\u0027s class overrides\n     * hashCode().\n     * The hash code for the null reference is zero.\n     *\n     * @param x object for which the hashCode is to be calculated\n     * @return  the hashCode\n     * @since   1.1\n     * @see Object#hashCode\n     * @see java.util.Objects#hashCode(Object)\n     */\n    @HotSpotIntrinsicCandidate\n    public static native int identityHashCode(Object x);\n\n    /**\n     * System properties. The following properties are guaranteed to be defined:\n     * \u003cdl\u003e\n     * \u003cdt\u003ejava.version         \u003cdd\u003eJava version number\n     * \u003cdt\u003ejava.version.date    \u003cdd\u003eJava version date\n     * \u003cdt\u003ejava.vendor          \u003cdd\u003eJava vendor specific string\n     * \u003cdt\u003ejava.vendor.url      \u003cdd\u003eJava vendor URL\n     * \u003cdt\u003ejava.vendor.version  \u003cdd\u003eJava vendor version\n     * \u003cdt\u003ejava.home            \u003cdd\u003eJava installation directory\n     * \u003cdt\u003ejava.class.version   \u003cdd\u003eJava class version number\n     * \u003cdt\u003ejava.class.path      \u003cdd\u003eJava classpath\n     * \u003cdt\u003eos.name              \u003cdd\u003eOperating System Name\n     * \u003cdt\u003eos.arch              \u003cdd\u003eOperating System Architecture\n     * \u003cdt\u003eos.version           \u003cdd\u003eOperating System Version\n     * \u003cdt\u003efile.separator       \u003cdd\u003eFile separator (\"/\" on Unix)\n     * \u003cdt\u003epath.separator       \u003cdd\u003ePath separator (\":\" on Unix)\n     * \u003cdt\u003eline.separator       \u003cdd\u003eLine separator (\"\\n\" on Unix)\n     * \u003cdt\u003euser.name            \u003cdd\u003eUser account name\n     * \u003cdt\u003euser.home            \u003cdd\u003eUser home directory\n     * \u003cdt\u003euser.dir             \u003cdd\u003eUser\u0027s current working directory\n     * \u003c/dl\u003e\n     */\n\n    private static Properties props;\n    private static native Properties initProperties(Properties props);\n\n    /**\n     * Determines the current system properties.\n     *\n     * First, if there is a security manager, its\n     * {@code checkPropertiesAccess} method is called with no\n     * arguments. This may result in a security exception.\n     * \u003cp\u003e\n     * The current set of system properties for use by the\n     * {@link #getProperty(String)} method is returned as a\n     * {@code Properties} object. If there is no current set of\n     * system properties, a set of system properties is first created and\n     * initialized. This set of system properties always includes values\n     * for the following keys:\n     * \u003ctable class\u003d\"striped\" style\u003d\"text-align:left\"\u003e\n     * \u003ccaption style\u003d\"display:none\"\u003eShows property keys and associated values\u003c/caption\u003e\n     * \u003cthead\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"col\"\u003eKey\u003c/th\u003e\n     *     \u003cth scope\u003d\"col\"\u003eDescription of Associated Value\u003c/th\u003e\u003c/tr\u003e\n     * \u003c/thead\u003e\n     * \u003ctbody\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@code java.version}\u003c/th\u003e\n     *     \u003ctd\u003eJava Runtime Environment version, which may be interpreted\n     *     as a {@link Runtime.Version}\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@code java.version.date}\u003c/th\u003e\n     *     \u003ctd\u003eJava Runtime Environment version date, in ISO-8601 YYYY-MM-DD\n     *     format, which may be interpreted as a {@link\n     *     java.time.LocalDate}\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@code java.vendor}\u003c/th\u003e\n     *     \u003ctd\u003eJava Runtime Environment vendor\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@code java.vendor.url}\u003c/th\u003e\n     *     \u003ctd\u003eJava vendor URL\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@code java.vendor.version}\u003c/th\u003e\n     *     \u003ctd\u003eJava vendor version\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@code java.home}\u003c/th\u003e\n     *     \u003ctd\u003eJava installation directory\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@code java.vm.specification.version}\u003c/th\u003e\n     *     \u003ctd\u003eJava Virtual Machine specification version, whose value is the\n     *     {@linkplain Runtime.Version#feature feature} element of the\n     *     {@linkplain Runtime#version() runtime version}\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@code java.vm.specification.vendor}\u003c/th\u003e\n     *     \u003ctd\u003eJava Virtual Machine specification vendor\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@code java.vm.specification.name}\u003c/th\u003e\n     *     \u003ctd\u003eJava Virtual Machine specification name\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@code java.vm.version}\u003c/th\u003e\n     *     \u003ctd\u003eJava Virtual Machine implementation version which may be\n     *     interpreted as a {@link Runtime.Version}\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@code java.vm.vendor}\u003c/th\u003e\n     *     \u003ctd\u003eJava Virtual Machine implementation vendor\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@code java.vm.name}\u003c/th\u003e\n     *     \u003ctd\u003eJava Virtual Machine implementation name\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@code java.specification.version}\u003c/th\u003e\n     *     \u003ctd\u003eJava Runtime Environment specification version, whose value is\n     *     the {@linkplain Runtime.Version#feature feature} element of the\n     *     {@linkplain Runtime#version() runtime version}\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@code java.specification.vendor}\u003c/th\u003e\n     *     \u003ctd\u003eJava Runtime Environment specification  vendor\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@code java.specification.name}\u003c/th\u003e\n     *     \u003ctd\u003eJava Runtime Environment specification  name\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@code java.class.version}\u003c/th\u003e\n     *     \u003ctd\u003eJava class format version number\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@code java.class.path}\u003c/th\u003e\n     *     \u003ctd\u003eJava class path  (refer to\n     *        {@link ClassLoader#getSystemClassLoader()} for details)\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@code java.library.path}\u003c/th\u003e\n     *     \u003ctd\u003eList of paths to search when loading libraries\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@code java.io.tmpdir}\u003c/th\u003e\n     *     \u003ctd\u003eDefault temp file path\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@code java.compiler}\u003c/th\u003e\n     *     \u003ctd\u003eName of JIT compiler to use\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@code os.name}\u003c/th\u003e\n     *     \u003ctd\u003eOperating system name\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@code os.arch}\u003c/th\u003e\n     *     \u003ctd\u003eOperating system architecture\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@code os.version}\u003c/th\u003e\n     *     \u003ctd\u003eOperating system version\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@code file.separator}\u003c/th\u003e\n     *     \u003ctd\u003eFile separator (\"/\" on UNIX)\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@code path.separator}\u003c/th\u003e\n     *     \u003ctd\u003ePath separator (\":\" on UNIX)\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@code line.separator}\u003c/th\u003e\n     *     \u003ctd\u003eLine separator (\"\\n\" on UNIX)\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@code user.name}\u003c/th\u003e\n     *     \u003ctd\u003eUser\u0027s account name\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@code user.home}\u003c/th\u003e\n     *     \u003ctd\u003eUser\u0027s home directory\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@code user.dir}\u003c/th\u003e\n     *     \u003ctd\u003eUser\u0027s current working directory\u003c/td\u003e\u003c/tr\u003e\n     * \u003c/tbody\u003e\n     * \u003c/table\u003e\n     * \u003cp\u003e\n     * Multiple paths in a system property value are separated by the path\n     * separator character of the platform.\n     * \u003cp\u003e\n     * Note that even if the security manager does not permit the\n     * {@code getProperties} operation, it may choose to permit the\n     * {@link #getProperty(String)} operation.\n     *\n     * @apiNote\n     * \u003cstrong\u003eChanging a standard system property may have unpredictable results\n     * unless otherwise specified.\u003c/strong\u003e\n     * Property values may be cached during initialization or on first use.\n     * Setting a standard property after initialization using {@link #getProperties()},\n     * {@link #setProperties(Properties)}, {@link #setProperty(String, String)}, or\n     * {@link #clearProperty(String)} may not have the desired effect.\n     *\n     * @implNote\n     * In addition to the standard system properties, the system\n     * properties may include the following keys:\n     * \u003ctable class\u003d\"striped\"\u003e\n     * \u003ccaption style\u003d\"display:none\"\u003eShows property keys and associated values\u003c/caption\u003e\n     * \u003cthead\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"col\"\u003eKey\u003c/th\u003e\n     *     \u003cth scope\u003d\"col\"\u003eDescription of Associated Value\u003c/th\u003e\u003c/tr\u003e\n     * \u003c/thead\u003e\n     * \u003ctbody\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@code jdk.module.path}\u003c/th\u003e\n     *     \u003ctd\u003eThe application module path\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@code jdk.module.upgrade.path}\u003c/th\u003e\n     *     \u003ctd\u003eThe upgrade module path\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@code jdk.module.main}\u003c/th\u003e\n     *     \u003ctd\u003eThe module name of the initial/main module\u003c/td\u003e\u003c/tr\u003e\n     * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@code jdk.module.main.class}\u003c/th\u003e\n     *     \u003ctd\u003eThe main class name of the initial module\u003c/td\u003e\u003c/tr\u003e\n     * \u003c/tbody\u003e\n     * \u003c/table\u003e\n     *\n     * @return     the system properties\n     * @throws     SecurityException  if a security manager exists and its\n     *             {@code checkPropertiesAccess} method doesn\u0027t allow access\n     *             to the system properties.\n     * @see        #setProperties\n     * @see        java.lang.SecurityException\n     * @see        java.lang.SecurityManager#checkPropertiesAccess()\n     * @see        java.util.Properties\n     */\n    public static Properties getProperties() {\n        SecurityManager sm \u003d getSecurityManager();\n        if (sm !\u003d null) {\n            sm.checkPropertiesAccess();\n        }\n\n        return props;\n    }\n\n    /**\n     * Returns the system-dependent line separator string.  It always\n     * returns the same value - the initial value of the {@linkplain\n     * #getProperty(String) system property} {@code line.separator}.\n     *\n     * \u003cp\u003eOn UNIX systems, it returns {@code \"\\n\"}; on Microsoft\n     * Windows systems it returns {@code \"\\r\\n\"}.\n     *\n     * @return the system-dependent line separator string\n     * @since 1.7\n     */\n    public static String lineSeparator() {\n        return lineSeparator;\n    }\n\n    private static String lineSeparator;\n\n    /**\n     * Sets the system properties to the {@code Properties} argument.\n     *\n     * First, if there is a security manager, its\n     * {@code checkPropertiesAccess} method is called with no\n     * arguments. This may result in a security exception.\n     * \u003cp\u003e\n     * The argument becomes the current set of system properties for use\n     * by the {@link #getProperty(String)} method. If the argument is\n     * {@code null}, then the current set of system properties is\n     * forgotten.\n     *\n     * @apiNote\n     * \u003cstrong\u003eChanging a standard system property may have unpredictable results\n     * unless otherwise specified\u003c/strong\u003e.\n     * See {@linkplain #getProperties getProperties} for details.\n     *\n     * @param      props   the new system properties.\n     * @throws     SecurityException  if a security manager exists and its\n     *             {@code checkPropertiesAccess} method doesn\u0027t allow access\n     *             to the system properties.\n     * @see        #getProperties\n     * @see        java.util.Properties\n     * @see        java.lang.SecurityException\n     * @see        java.lang.SecurityManager#checkPropertiesAccess()\n     */\n    public static void setProperties(Properties props) {\n        SecurityManager sm \u003d getSecurityManager();\n        if (sm !\u003d null) {\n            sm.checkPropertiesAccess();\n        }\n        if (props \u003d\u003d null) {\n            props \u003d new Properties();\n            initProperties(props);\n        }\n        System.props \u003d props;\n    }\n\n    /**\n     * Gets the system property indicated by the specified key.\n     *\n     * First, if there is a security manager, its\n     * {@code checkPropertyAccess} method is called with the key as\n     * its argument. This may result in a SecurityException.\n     * \u003cp\u003e\n     * If there is no current set of system properties, a set of system\n     * properties is first created and initialized in the same manner as\n     * for the {@code getProperties} method.\n     *\n     * @apiNote\n     * \u003cstrong\u003eChanging a standard system property may have unpredictable results\n     * unless otherwise specified\u003c/strong\u003e.\n     * See {@linkplain #getProperties getProperties} for details.\n     *\n     * @param      key   the name of the system property.\n     * @return     the string value of the system property,\n     *             or {@code null} if there is no property with that key.\n     *\n     * @throws     SecurityException  if a security manager exists and its\n     *             {@code checkPropertyAccess} method doesn\u0027t allow\n     *             access to the specified system property.\n     * @throws     NullPointerException if {@code key} is {@code null}.\n     * @throws     IllegalArgumentException if {@code key} is empty.\n     * @see        #setProperty\n     * @see        java.lang.SecurityException\n     * @see        java.lang.SecurityManager#checkPropertyAccess(java.lang.String)\n     * @see        java.lang.System#getProperties()\n     */\n    public static String getProperty(String key) {\n        checkKey(key);\n        SecurityManager sm \u003d getSecurityManager();\n        if (sm !\u003d null) {\n            sm.checkPropertyAccess(key);\n        }\n\n        return props.getProperty(key);\n    }\n\n    /**\n     * Gets the system property indicated by the specified key.\n     *\n     * First, if there is a security manager, its\n     * {@code checkPropertyAccess} method is called with the\n     * {@code key} as its argument.\n     * \u003cp\u003e\n     * If there is no current set of system properties, a set of system\n     * properties is first created and initialized in the same manner as\n     * for the {@code getProperties} method.\n     *\n     * @param      key   the name of the system property.\n     * @param      def   a default value.\n     * @return     the string value of the system property,\n     *             or the default value if there is no property with that key.\n     *\n     * @throws     SecurityException  if a security manager exists and its\n     *             {@code checkPropertyAccess} method doesn\u0027t allow\n     *             access to the specified system property.\n     * @throws     NullPointerException if {@code key} is {@code null}.\n     * @throws     IllegalArgumentException if {@code key} is empty.\n     * @see        #setProperty\n     * @see        java.lang.SecurityManager#checkPropertyAccess(java.lang.String)\n     * @see        java.lang.System#getProperties()\n     */\n    public static String getProperty(String key, String def) {\n        checkKey(key);\n        SecurityManager sm \u003d getSecurityManager();\n        if (sm !\u003d null) {\n            sm.checkPropertyAccess(key);\n        }\n\n        return props.getProperty(key, def);\n    }\n\n    /**\n     * Sets the system property indicated by the specified key.\n     *\n     * First, if a security manager exists, its\n     * {@code SecurityManager.checkPermission} method\n     * is called with a {@code PropertyPermission(key, \"write\")}\n     * permission. This may result in a SecurityException being thrown.\n     * If no exception is thrown, the specified property is set to the given\n     * value.\n     *\n     * @apiNote\n     * \u003cstrong\u003eChanging a standard system property may have unpredictable results\n     * unless otherwise specified\u003c/strong\u003e.\n     * See {@linkplain #getProperties getProperties} for details.\n     *\n     * @param      key   the name of the system property.\n     * @param      value the value of the system property.\n     * @return     the previous value of the system property,\n     *             or {@code null} if it did not have one.\n     *\n     * @throws     SecurityException  if a security manager exists and its\n     *             {@code checkPermission} method doesn\u0027t allow\n     *             setting of the specified property.\n     * @throws     NullPointerException if {@code key} or\n     *             {@code value} is {@code null}.\n     * @throws     IllegalArgumentException if {@code key} is empty.\n     * @see        #getProperty\n     * @see        java.lang.System#getProperty(java.lang.String)\n     * @see        java.lang.System#getProperty(java.lang.String, java.lang.String)\n     * @see        java.util.PropertyPermission\n     * @see        SecurityManager#checkPermission\n     * @since      1.2\n     */\n    public static String setProperty(String key, String value) {\n        checkKey(key);\n        SecurityManager sm \u003d getSecurityManager();\n        if (sm !\u003d null) {\n            sm.checkPermission(new PropertyPermission(key,\n                SecurityConstants.PROPERTY_WRITE_ACTION));\n        }\n\n        return (String) props.setProperty(key, value);\n    }\n\n    /**\n     * Removes the system property indicated by the specified key.\n     *\n     * First, if a security manager exists, its\n     * {@code SecurityManager.checkPermission} method\n     * is called with a {@code PropertyPermission(key, \"write\")}\n     * permission. This may result in a SecurityException being thrown.\n     * If no exception is thrown, the specified property is removed.\n     *\n     * @apiNote\n     * \u003cstrong\u003eChanging a standard system property may have unpredictable results\n     * unless otherwise specified\u003c/strong\u003e.\n     * See {@linkplain #getProperties getProperties} method for details.\n     *\n     * @param      key   the name of the system property to be removed.\n     * @return     the previous string value of the system property,\n     *             or {@code null} if there was no property with that key.\n     *\n     * @throws     SecurityException  if a security manager exists and its\n     *             {@code checkPropertyAccess} method doesn\u0027t allow\n     *              access to the specified system property.\n     * @throws     NullPointerException if {@code key} is {@code null}.\n     * @throws     IllegalArgumentException if {@code key} is empty.\n     * @see        #getProperty\n     * @see        #setProperty\n     * @see        java.util.Properties\n     * @see        java.lang.SecurityException\n     * @see        java.lang.SecurityManager#checkPropertiesAccess()\n     * @since 1.5\n     */\n    public static String clearProperty(String key) {\n        checkKey(key);\n        SecurityManager sm \u003d getSecurityManager();\n        if (sm !\u003d null) {\n            sm.checkPermission(new PropertyPermission(key, \"write\"));\n        }\n\n        return (String) props.remove(key);\n    }\n\n    private static void checkKey(String key) {\n        if (key \u003d\u003d null) {\n            throw new NullPointerException(\"key can\u0027t be null\");\n        }\n        if (key.equals(\"\")) {\n            throw new IllegalArgumentException(\"key can\u0027t be empty\");\n        }\n    }\n\n    /**\n     * Gets the value of the specified environment variable. An\n     * environment variable is a system-dependent external named\n     * value.\n     *\n     * \u003cp\u003eIf a security manager exists, its\n     * {@link SecurityManager#checkPermission checkPermission}\n     * method is called with a\n     * {@code {@link RuntimePermission}(\"getenv.\"+name)}\n     * permission.  This may result in a {@link SecurityException}\n     * being thrown.  If no exception is thrown the value of the\n     * variable {@code name} is returned.\n     *\n     * \u003cp\u003e\u003ca id\u003d\"EnvironmentVSSystemProperties\"\u003e\u003ci\u003eSystem\n     * properties\u003c/i\u003e and \u003ci\u003eenvironment variables\u003c/i\u003e\u003c/a\u003e are both\n     * conceptually mappings between names and values.  Both\n     * mechanisms can be used to pass user-defined information to a\n     * Java process.  Environment variables have a more global effect,\n     * because they are visible to all descendants of the process\n     * which defines them, not just the immediate Java subprocess.\n     * They can have subtly different semantics, such as case\n     * insensitivity, on different operating systems.  For these\n     * reasons, environment variables are more likely to have\n     * unintended side effects.  It is best to use system properties\n     * where possible.  Environment variables should be used when a\n     * global effect is desired, or when an external system interface\n     * requires an environment variable (such as {@code PATH}).\n     *\n     * \u003cp\u003eOn UNIX systems the alphabetic case of {@code name} is\n     * typically significant, while on Microsoft Windows systems it is\n     * typically not.  For example, the expression\n     * {@code System.getenv(\"FOO\").equals(System.getenv(\"foo\"))}\n     * is likely to be true on Microsoft Windows.\n     *\n     * @param  name the name of the environment variable\n     * @return the string value of the variable, or {@code null}\n     *         if the variable is not defined in the system environment\n     * @throws NullPointerException if {@code name} is {@code null}\n     * @throws SecurityException\n     *         if a security manager exists and its\n     *         {@link SecurityManager#checkPermission checkPermission}\n     *         method doesn\u0027t allow access to the environment variable\n     *         {@code name}\n     * @see    #getenv()\n     * @see    ProcessBuilder#environment()\n     */\n    public static String getenv(String name) {\n        SecurityManager sm \u003d getSecurityManager();\n        if (sm !\u003d null) {\n            sm.checkPermission(new RuntimePermission(\"getenv.\"+name));\n        }\n\n        return ProcessEnvironment.getenv(name);\n    }\n\n\n    /**\n     * Returns an unmodifiable string map view of the current system environment.\n     * The environment is a system-dependent mapping from names to\n     * values which is passed from parent to child processes.\n     *\n     * \u003cp\u003eIf the system does not support environment variables, an\n     * empty map is returned.\n     *\n     * \u003cp\u003eThe returned map will never contain null keys or values.\n     * Attempting to query the presence of a null key or value will\n     * throw a {@link NullPointerException}.  Attempting to query\n     * the presence of a key or value which is not of type\n     * {@link String} will throw a {@link ClassCastException}.\n     *\n     * \u003cp\u003eThe returned map and its collection views may not obey the\n     * general contract of the {@link Object#equals} and\n     * {@link Object#hashCode} methods.\n     *\n     * \u003cp\u003eThe returned map is typically case-sensitive on all platforms.\n     *\n     * \u003cp\u003eIf a security manager exists, its\n     * {@link SecurityManager#checkPermission checkPermission}\n     * method is called with a\n     * {@code {@link RuntimePermission}(\"getenv.*\")} permission.\n     * This may result in a {@link SecurityException} being thrown.\n     *\n     * \u003cp\u003eWhen passing information to a Java subprocess,\n     * \u003ca href\u003d#EnvironmentVSSystemProperties\u003esystem properties\u003c/a\u003e\n     * are generally preferred over environment variables.\n     *\n     * @return the environment as a map of variable names to values\n     * @throws SecurityException\n     *         if a security manager exists and its\n     *         {@link SecurityManager#checkPermission checkPermission}\n     *         method doesn\u0027t allow access to the process environment\n     * @see    #getenv(String)\n     * @see    ProcessBuilder#environment()\n     * @since  1.5\n     */\n    public static java.util.Map\u003cString,String\u003e getenv() {\n        SecurityManager sm \u003d getSecurityManager();\n        if (sm !\u003d null) {\n            sm.checkPermission(new RuntimePermission(\"getenv.*\"));\n        }\n\n        return ProcessEnvironment.getenv();\n    }\n\n    /**\n     * {@code System.Logger} instances log messages that will be\n     * routed to the underlying logging framework the {@link System.LoggerFinder\n     * LoggerFinder} uses.\n     *\n     * {@code System.Logger} instances are typically obtained from\n     * the {@link java.lang.System System} class, by calling\n     * {@link java.lang.System#getLogger(java.lang.String) System.getLogger(loggerName)}\n     * or {@link java.lang.System#getLogger(java.lang.String, java.util.ResourceBundle)\n     * System.getLogger(loggerName, bundle)}.\n     *\n     * @see java.lang.System#getLogger(java.lang.String)\n     * @see java.lang.System#getLogger(java.lang.String, java.util.ResourceBundle)\n     * @see java.lang.System.LoggerFinder\n     *\n     * @since 9\n     */\n    public interface Logger {\n\n        /**\n         * System {@linkplain Logger loggers} levels.\n         *\n         * A level has a {@linkplain #getName() name} and {@linkplain\n         * #getSeverity() severity}.\n         * Level values are {@link #ALL}, {@link #TRACE}, {@link #DEBUG},\n         * {@link #INFO}, {@link #WARNING}, {@link #ERROR}, {@link #OFF},\n         * by order of increasing severity.\n         * \u003cbr\u003e\n         * {@link #ALL} and {@link #OFF}\n         * are simple markers with severities mapped respectively to\n         * {@link java.lang.Integer#MIN_VALUE Integer.MIN_VALUE} and\n         * {@link java.lang.Integer#MAX_VALUE Integer.MAX_VALUE}.\n         * \u003cp\u003e\n         * \u003cb\u003eSeverity values and Mapping to {@code java.util.logging.Level}.\u003c/b\u003e\n         * \u003cp\u003e\n         * {@linkplain System.Logger.Level System logger levels} are mapped to\n         * {@linkplain java.util.logging.Level  java.util.logging levels}\n         * of corresponding severity.\n         * \u003cbr\u003eThe mapping is as follows:\n         * \u003cbr\u003e\u003cbr\u003e\n         * \u003ctable class\u003d\"striped\"\u003e\n         * \u003ccaption\u003eSystem.Logger Severity Level Mapping\u003c/caption\u003e\n         * \u003cthead\u003e\n         * \u003ctr\u003e\u003cth scope\u003d\"col\"\u003eSystem.Logger Levels\u003c/th\u003e\n         *     \u003cth scope\u003d\"col\"\u003ejava.util.logging Levels\u003c/th\u003e\n         * \u003c/thead\u003e\n         * \u003ctbody\u003e\n         * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@link Logger.Level#ALL ALL}\u003c/th\u003e\n         *     \u003ctd\u003e{@link java.util.logging.Level#ALL ALL}\u003c/td\u003e\n         * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@link Logger.Level#TRACE TRACE}\u003c/th\u003e\n         *     \u003ctd\u003e{@link java.util.logging.Level#FINER FINER}\u003c/td\u003e\n         * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@link Logger.Level#DEBUG DEBUG}\u003c/th\u003e\n         *     \u003ctd\u003e{@link java.util.logging.Level#FINE FINE}\u003c/td\u003e\n         * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@link Logger.Level#INFO INFO}\u003c/th\u003e\n         *     \u003ctd\u003e{@link java.util.logging.Level#INFO INFO}\u003c/td\u003e\n         * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@link Logger.Level#WARNING WARNING}\u003c/th\u003e\n         *     \u003ctd\u003e{@link java.util.logging.Level#WARNING WARNING}\u003c/td\u003e\n         * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@link Logger.Level#ERROR ERROR}\u003c/th\u003e\n         *     \u003ctd\u003e{@link java.util.logging.Level#SEVERE SEVERE}\u003c/td\u003e\n         * \u003ctr\u003e\u003cth scope\u003d\"row\"\u003e{@link Logger.Level#OFF OFF}\u003c/th\u003e\n         *     \u003ctd\u003e{@link java.util.logging.Level#OFF OFF}\u003c/td\u003e\n         * \u003c/tbody\u003e\n         * \u003c/table\u003e\n         *\n         * @since 9\n         *\n         * @see java.lang.System.LoggerFinder\n         * @see java.lang.System.Logger\n         */\n        public enum Level {\n\n            // for convenience, we\u0027re reusing java.util.logging.Level int values\n            // the mapping logic in sun.util.logging.PlatformLogger depends\n            // on this.\n            /**\n             * A marker to indicate that all levels are enabled.\n             * This level {@linkplain #getSeverity() severity} is\n             * {@link Integer#MIN_VALUE}.\n             */\n            ALL(Integer.MIN_VALUE),  // typically mapped to/from j.u.l.Level.ALL\n            /**\n             * {@code TRACE} level: usually used to log diagnostic information.\n             * This level {@linkplain #getSeverity() severity} is\n             * {@code 400}.\n             */\n            TRACE(400),   // typically mapped to/from j.u.l.Level.FINER\n            /**\n             * {@code DEBUG} level: usually used to log debug information traces.\n             * This level {@linkplain #getSeverity() severity} is\n             * {@code 500}.\n             */\n            DEBUG(500),   // typically mapped to/from j.u.l.Level.FINEST/FINE/CONFIG\n            /**\n             * {@code INFO} level: usually used to log information messages.\n             * This level {@linkplain #getSeverity() severity} is\n             * {@code 800}.\n             */\n            INFO(800),    // typically mapped to/from j.u.l.Level.INFO\n            /**\n             * {@code WARNING} level: usually used to log warning messages.\n             * This level {@linkplain #getSeverity() severity} is\n             * {@code 900}.\n             */\n            WARNING(900), // typically mapped to/from j.u.l.Level.WARNING\n            /**\n             * {@code ERROR} level: usually used to log error messages.\n             * This level {@linkplain #getSeverity() severity} is\n             * {@code 1000}.\n             */\n            ERROR(1000),  // typically mapped to/from j.u.l.Level.SEVERE\n            /**\n             * A marker to indicate that all levels are disabled.\n             * This level {@linkplain #getSeverity() severity} is\n             * {@link Integer#MAX_VALUE}.\n             */\n            OFF(Integer.MAX_VALUE);  // typically mapped to/from j.u.l.Level.OFF\n\n            private final int severity;\n\n            private Level(int severity) {\n                this.severity \u003d severity;\n            }\n\n            /**\n             * Returns the name of this level.\n             * @return this level {@linkplain #name()}.\n             */\n            public final String getName() {\n                return name();\n            }\n\n            /**\n             * Returns the severity of this level.\n             * A higher severity means a more severe condition.\n             * @return this level severity.\n             */\n            public final int getSeverity() {\n                return severity;\n            }\n        }\n\n        /**\n         * Returns the name of this logger.\n         *\n         * @return the logger name.\n         */\n        public String getName();\n\n        /**\n         * Checks if a message of the given level would be logged by\n         * this logger.\n         *\n         * @param level the log message level.\n         * @return {@code true} if the given log message level is currently\n         *         being logged.\n         *\n         * @throws NullPointerException if {@code level} is {@code null}.\n         */\n        public boolean isLoggable(Level level);\n\n        /**\n         * Logs a message.\n         *\n         * @implSpec The default implementation for this method calls\n         * {@code this.log(level, (ResourceBundle)null, msg, (Object[])null);}\n         *\n         * @param level the log message level.\n         * @param msg the string message (or a key in the message catalog, if\n         * this logger is a {@link\n         * LoggerFinder#getLocalizedLogger(java.lang.String,\n         * java.util.ResourceBundle, java.lang.Module) localized logger});\n         * can be {@code null}.\n         *\n         * @throws NullPointerException if {@code level} is {@code null}.\n         */\n        public default void log(Level level, String msg) {\n            log(level, (ResourceBundle) null, msg, (Object[]) null);\n        }\n\n        /**\n         * Logs a lazily supplied message.\n         *\n         * If the logger is currently enabled for the given log message level\n         * then a message is logged that is the result produced by the\n         * given supplier function.  Otherwise, the supplier is not operated on.\n         *\n         * @implSpec When logging is enabled for the given level, the default\n         * implementation for this method calls\n         * {@code this.log(level, (ResourceBundle)null, msgSupplier.get(), (Object[])null);}\n         *\n         * @param level the log message level.\n         * @param msgSupplier a supplier function that produces a message.\n         *\n         * @throws NullPointerException if {@code level} is {@code null},\n         *         or {@code msgSupplier} is {@code null}.\n         */\n        public default void log(Level level, Supplier\u003cString\u003e msgSupplier) {\n            Objects.requireNonNull(msgSupplier);\n            if (isLoggable(Objects.requireNonNull(level))) {\n                log(level, (ResourceBundle) null, msgSupplier.get(), (Object[]) null);\n            }\n        }\n\n        /**\n         * Logs a message produced from the given object.\n         *\n         * If the logger is currently enabled for the given log message level then\n         * a message is logged that, by default, is the result produced from\n         * calling  toString on the given object.\n         * Otherwise, the object is not operated on.\n         *\n         * @implSpec When logging is enabled for the given level, the default\n         * implementation for this method calls\n         * {@code this.log(level, (ResourceBundle)null, obj.toString(), (Object[])null);}\n         *\n         * @param level the log message level.\n         * @param obj the object to log.\n         *\n         * @throws NullPointerException if {@code level} is {@code null}, or\n         *         {@code obj} is {@code null}.\n         */\n        public default void log(Level level, Object obj) {\n            Objects.requireNonNull(obj);\n            if (isLoggable(Objects.requireNonNull(level))) {\n                this.log(level, (ResourceBundle) null, obj.toString(), (Object[]) null);\n            }\n        }\n\n        /**\n         * Logs a message associated with a given throwable.\n         *\n         * @implSpec The default implementation for this method calls\n         * {@code this.log(level, (ResourceBundle)null, msg, thrown);}\n         *\n         * @param level the log message level.\n         * @param msg the string message (or a key in the message catalog, if\n         * this logger is a {@link\n         * LoggerFinder#getLocalizedLogger(java.lang.String,\n         * java.util.ResourceBundle, java.lang.Module) localized logger});\n         * can be {@code null}.\n         * @param thrown a {@code Throwable} associated with the log message;\n         *        can be {@code null}.\n         *\n         * @throws NullPointerException if {@code level} is {@code null}.\n         */\n        public default void log(Level level, String msg, Throwable thrown) {\n            this.log(level, null, msg, thrown);\n        }\n\n        /**\n         * Logs a lazily supplied message associated with a given throwable.\n         *\n         * If the logger is currently enabled for the given log message level\n         * then a message is logged that is the result produced by the\n         * given supplier function.  Otherwise, the supplier is not operated on.\n         *\n         * @implSpec When logging is enabled for the given level, the default\n         * implementation for this method calls\n         * {@code this.log(level, (ResourceBundle)null, msgSupplier.get(), thrown);}\n         *\n         * @param level one of the log message level identifiers.\n         * @param msgSupplier a supplier function that produces a message.\n         * @param thrown a {@code Throwable} associated with log message;\n         *               can be {@code null}.\n         *\n         * @throws NullPointerException if {@code level} is {@code null}, or\n         *                               {@code msgSupplier} is {@code null}.\n         */\n        public default void log(Level level, Supplier\u003cString\u003e msgSupplier,\n                Throwable thrown) {\n            Objects.requireNonNull(msgSupplier);\n            if (isLoggable(Objects.requireNonNull(level))) {\n                this.log(level, null, msgSupplier.get(), thrown);\n            }\n        }\n\n        /**\n         * Logs a message with an optional list of parameters.\n         *\n         * @implSpec The default implementation for this method calls\n         * {@code this.log(level, (ResourceBundle)null, format, params);}\n         *\n         * @param level one of the log message level identifiers.\n         * @param format the string message format in {@link\n         * java.text.MessageFormat} format, (or a key in the message\n         * catalog, if this logger is a {@link\n         * LoggerFinder#getLocalizedLogger(java.lang.String,\n         * java.util.ResourceBundle, java.lang.Module) localized logger});\n         * can be {@code null}.\n         * @param params an optional list of parameters to the message (may be\n         * none).\n         *\n         * @throws NullPointerException if {@code level} is {@code null}.\n         */\n        public default void log(Level level, String format, Object... params) {\n            this.log(level, null, format, params);\n        }\n\n        /**\n         * Logs a localized message associated with a given throwable.\n         *\n         * If the given resource bundle is non-{@code null},  the {@code msg}\n         * string is localized using the given resource bundle.\n         * Otherwise the {@code msg} string is not localized.\n         *\n         * @param level the log message level.\n         * @param bundle a resource bundle to localize {@code msg}; can be\n         * {@code null}.\n         * @param msg the string message (or a key in the message catalog,\n         *            if {@code bundle} is not {@code null}); can be {@code null}.\n         * @param thrown a {@code Throwable} associated with the log message;\n         *        can be {@code null}.\n         *\n         * @throws NullPointerException if {@code level} is {@code null}.\n         */\n        public void log(Level level, ResourceBundle bundle, String msg,\n                Throwable thrown);\n\n        /**\n         * Logs a message with resource bundle and an optional list of\n         * parameters.\n         *\n         * If the given resource bundle is non-{@code null},  the {@code format}\n         * string is localized using the given resource bundle.\n         * Otherwise the {@code format} string is not localized.\n         *\n         * @param level the log message level.\n         * @param bundle a resource bundle to localize {@code format}; can be\n         * {@code null}.\n         * @param format the string message format in {@link\n         * java.text.MessageFormat} format, (or a key in the message\n         * catalog if {@code bundle} is not {@code null}); can be {@code null}.\n         * @param params an optional list of parameters to the message (may be\n         * none).\n         *\n         * @throws NullPointerException if {@code level} is {@code null}.\n         */\n        public void log(Level level, ResourceBundle bundle, String format,\n                Object... params);\n    }\n\n    /**\n     * The {@code LoggerFinder} service is responsible for creating, managing,\n     * and configuring loggers to the underlying framework it uses.\n     *\n     * A logger finder is a concrete implementation of this class that has a\n     * zero-argument constructor and implements the abstract methods defined\n     * by this class.\n     * The loggers returned from a logger finder are capable of routing log\n     * messages to the logging backend this provider supports.\n     * A given invocation of the Java Runtime maintains a single\n     * system-wide LoggerFinder instance that is loaded as follows:\n     * \u003cul\u003e\n     *    \u003cli\u003eFirst it finds any custom {@code LoggerFinder} provider\n     *        using the {@link java.util.ServiceLoader} facility with the\n     *        {@linkplain ClassLoader#getSystemClassLoader() system class\n     *        loader}.\u003c/li\u003e\n     *    \u003cli\u003eIf no {@code LoggerFinder} provider is found, the system default\n     *        {@code LoggerFinder} implementation will be used.\u003c/li\u003e\n     * \u003c/ul\u003e\n     * \u003cp\u003e\n     * An application can replace the logging backend\n     * \u003ci\u003eeven when the java.logging module is present\u003c/i\u003e, by simply providing\n     * and declaring an implementation of the {@link LoggerFinder} service.\n     * \u003cp\u003e\n     * \u003cb\u003eDefault Implementation\u003c/b\u003e\n     * \u003cp\u003e\n     * The system default {@code LoggerFinder} implementation uses\n     * {@code java.util.logging} as the backend framework when the\n     * {@code java.logging} module is present.\n     * It returns a {@linkplain System.Logger logger} instance\n     * that will route log messages to a {@link java.util.logging.Logger\n     * java.util.logging.Logger}. Otherwise, if {@code java.logging} is not\n     * present, the default implementation will return a simple logger\n     * instance that will route log messages of {@code INFO} level and above to\n     * the console ({@code System.err}).\n     * \u003cp\u003e\n     * \u003cb\u003eLogging Configuration\u003c/b\u003e\n     * \u003cp\u003e\n     * {@linkplain Logger Logger} instances obtained from the\n     * {@code LoggerFinder} factory methods are not directly configurable by\n     * the application. Configuration is the responsibility of the underlying\n     * logging backend, and usually requires using APIs specific to that backend.\n     * \u003cp\u003eFor the default {@code LoggerFinder} implementation\n     * using {@code java.util.logging} as its backend, refer to\n     * {@link java.util.logging java.util.logging} for logging configuration.\n     * For the default {@code LoggerFinder} implementation returning simple loggers\n     * when the {@code java.logging} module is absent, the configuration\n     * is implementation dependent.\n     * \u003cp\u003e\n     * Usually an application that uses a logging framework will log messages\n     * through a logger facade defined (or supported) by that framework.\n     * Applications that wish to use an external framework should log\n     * through the facade associated with that framework.\n     * \u003cp\u003e\n     * A system class that needs to log messages will typically obtain\n     * a {@link System.Logger} instance to route messages to the logging\n     * framework selected by the application.\n     * \u003cp\u003e\n     * Libraries and classes that only need loggers to produce log messages\n     * should not attempt to configure loggers by themselves, as that\n     * would make them dependent from a specific implementation of the\n     * {@code LoggerFinder} service.\n     * \u003cp\u003e\n     * In addition, when a security manager is present, loggers provided to\n     * system classes should not be directly configurable through the logging\n     * backend without requiring permissions.\n     * \u003cbr\u003e\n     * It is the responsibility of the provider of\n     * the concrete {@code LoggerFinder} implementation to ensure that\n     * these loggers are not configured by untrusted code without proper\n     * permission checks, as configuration performed on such loggers usually\n     * affects all applications in the same Java Runtime.\n     * \u003cp\u003e\n     * \u003cb\u003eMessage Levels and Mapping to backend levels\u003c/b\u003e\n     * \u003cp\u003e\n     * A logger finder is responsible for mapping from a {@code\n     * System.Logger.Level} to a level supported by the logging backend it uses.\n     * \u003cbr\u003eThe default LoggerFinder using {@code java.util.logging} as the backend\n     * maps {@code System.Logger} levels to\n     * {@linkplain java.util.logging.Level java.util.logging} levels\n     * of corresponding severity - as described in {@link Logger.Level\n     * Logger.Level}.\n     *\n     * @see java.lang.System\n     * @see java.lang.System.Logger\n     *\n     * @since 9\n     */\n    public static abstract class LoggerFinder {\n        /**\n         * The {@code RuntimePermission(\"loggerFinder\")} is\n         * necessary to subclass and instantiate the {@code LoggerFinder} class,\n         * as well as to obtain loggers from an instance of that class.\n         */\n        static final RuntimePermission LOGGERFINDER_PERMISSION \u003d\n                new RuntimePermission(\"loggerFinder\");\n\n        /**\n         * Creates a new instance of {@code LoggerFinder}.\n         *\n         * @implNote It is recommended that a {@code LoggerFinder} service\n         *   implementation does not perform any heavy initialization in its\n         *   constructor, in order to avoid possible risks of deadlock or class\n         *   loading cycles during the instantiation of the service provider.\n         *\n         * @throws SecurityException if a security manager is present and its\n         *         {@code checkPermission} method doesn\u0027t allow the\n         *         {@code RuntimePermission(\"loggerFinder\")}.\n         */\n        protected LoggerFinder() {\n            this(checkPermission());\n        }\n\n        private LoggerFinder(Void unused) {\n            // nothing to do.\n        }\n\n        private static Void checkPermission() {\n            final SecurityManager sm \u003d System.getSecurityManager();\n            if (sm !\u003d null) {\n                sm.checkPermission(LOGGERFINDER_PERMISSION);\n            }\n            return null;\n        }\n\n        /**\n         * Returns an instance of {@link Logger Logger}\n         * for the given {@code module}.\n         *\n         * @param name the name of the logger.\n         * @param module the module for which the logger is being requested.\n         *\n         * @return a {@link Logger logger} suitable for use within the given\n         *         module.\n         * @throws NullPointerException if {@code name} is {@code null} or\n         *        {@code module} is {@code null}.\n         * @throws SecurityException if a security manager is present and its\n         *         {@code checkPermission} method doesn\u0027t allow the\n         *         {@code RuntimePermission(\"loggerFinder\")}.\n         */\n        public abstract Logger getLogger(String name, Module module);\n\n        /**\n         * Returns a localizable instance of {@link Logger Logger}\n         * for the given {@code module}.\n         * The returned logger will use the provided resource bundle for\n         * message localization.\n         *\n         * @implSpec By default, this method calls {@link\n         * #getLogger(java.lang.String, java.lang.Module)\n         * this.getLogger(name, module)} to obtain a logger, then wraps that\n         * logger in a {@link Logger} instance where all methods that do not\n         * take a {@link ResourceBundle} as parameter are redirected to one\n         * which does - passing the given {@code bundle} for\n         * localization. So for instance, a call to {@link\n         * Logger#log(Logger.Level, String) Logger.log(Level.INFO, msg)}\n         * will end up as a call to {@link\n         * Logger#log(Logger.Level, ResourceBundle, String, Object...)\n         * Logger.log(Level.INFO, bundle, msg, (Object[])null)} on the wrapped\n         * logger instance.\n         * Note however that by default, string messages returned by {@link\n         * java.util.function.Supplier Supplier\u0026lt;String\u0026gt;} will not be\n         * localized, as it is assumed that such strings are messages which are\n         * already constructed, rather than keys in a resource bundle.\n         * \u003cp\u003e\n         * An implementation of {@code LoggerFinder} may override this method,\n         * for example, when the underlying logging backend provides its own\n         * mechanism for localizing log messages, then such a\n         * {@code LoggerFinder} would be free to return a logger\n         * that makes direct use of the mechanism provided by the backend.\n         *\n         * @param name    the name of the logger.\n         * @param bundle  a resource bundle; can be {@code null}.\n         * @param module  the module for which the logger is being requested.\n         * @return an instance of {@link Logger Logger}  which will use the\n         * provided resource bundle for message localization.\n         *\n         * @throws NullPointerException if {@code name} is {@code null} or\n         *         {@code module} is {@code null}.\n         * @throws SecurityException if a security manager is present and its\n         *         {@code checkPermission} method doesn\u0027t allow the\n         *         {@code RuntimePermission(\"loggerFinder\")}.\n         */\n        public Logger getLocalizedLogger(String name, ResourceBundle bundle,\n                                         Module module) {\n            return new LocalizedLoggerWrapper\u003c\u003e(getLogger(name, module), bundle);\n        }\n\n        /**\n         * Returns the {@code LoggerFinder} instance. There is one\n         * single system-wide {@code LoggerFinder} instance in\n         * the Java Runtime.  See the class specification of how the\n         * {@link LoggerFinder LoggerFinder} implementation is located and\n         * loaded.\n\n         * @return the {@link LoggerFinder LoggerFinder} instance.\n         * @throws SecurityException if a security manager is present and its\n         *         {@code checkPermission} method doesn\u0027t allow the\n         *         {@code RuntimePermission(\"loggerFinder\")}.\n         */\n        public static LoggerFinder getLoggerFinder() {\n            final SecurityManager sm \u003d System.getSecurityManager();\n            if (sm !\u003d null) {\n                sm.checkPermission(LOGGERFINDER_PERMISSION);\n            }\n            return accessProvider();\n        }\n\n\n        private static volatile LoggerFinder service;\n        static LoggerFinder accessProvider() {\n            // We do not need to synchronize: LoggerFinderLoader will\n            // always return the same instance, so if we don\u0027t have it,\n            // just fetch it again.\n            if (service \u003d\u003d null) {\n                PrivilegedAction\u003cLoggerFinder\u003e pa \u003d\n                        () -\u003e LoggerFinderLoader.getLoggerFinder();\n                service \u003d AccessController.doPrivileged(pa, null,\n                        LOGGERFINDER_PERMISSION);\n            }\n            return service;\n        }\n\n    }\n\n\n    /**\n     * Returns an instance of {@link Logger Logger} for the caller\u0027s\n     * use.\n     *\n     * @implSpec\n     * Instances returned by this method route messages to loggers\n     * obtained by calling {@link LoggerFinder#getLogger(java.lang.String,\n     * java.lang.Module) LoggerFinder.getLogger(name, module)}, where\n     * {@code module} is the caller\u0027s module.\n     * In cases where {@code System.getLogger} is called from a context where\n     * there is no caller frame on the stack (e.g when called directly\n     * from a JNI attached thread), {@code IllegalCallerException} is thrown.\n     * To obtain a logger in such a context, use an auxiliary class that will\n     * implicitly be identified as the caller, or use the system {@link\n     * LoggerFinder#getLoggerFinder() LoggerFinder} to obtain a logger instead.\n     * Note that doing the latter may eagerly initialize the underlying\n     * logging system.\n     *\n     * @apiNote\n     * This method may defer calling the {@link\n     * LoggerFinder#getLogger(java.lang.String, java.lang.Module)\n     * LoggerFinder.getLogger} method to create an actual logger supplied by\n     * the logging backend, for instance, to allow loggers to be obtained during\n     * the system initialization time.\n     *\n     * @param name the name of the logger.\n     * @return an instance of {@link Logger} that can be used by the calling\n     *         class.\n     * @throws NullPointerException if {@code name} is {@code null}.\n     * @throws IllegalCallerException if there is no Java caller frame on the\n     *         stack.\n     *\n     * @since 9\n     */\n    @CallerSensitive\n    public static Logger getLogger(String name) {\n        Objects.requireNonNull(name);\n        final Class\u003c?\u003e caller \u003d Reflection.getCallerClass();\n        if (caller \u003d\u003d null) {\n            throw new IllegalCallerException(\"no caller frame\");\n        }\n        return LazyLoggers.getLogger(name, caller.getModule());\n    }\n\n    /**\n     * Returns a localizable instance of {@link Logger\n     * Logger} for the caller\u0027s use.\n     * The returned logger will use the provided resource bundle for message\n     * localization.\n     *\n     * @implSpec\n     * The returned logger will perform message localization as specified\n     * by {@link LoggerFinder#getLocalizedLogger(java.lang.String,\n     * java.util.ResourceBundle, java.lang.Module)\n     * LoggerFinder.getLocalizedLogger(name, bundle, module)}, where\n     * {@code module} is the caller\u0027s module.\n     * In cases where {@code System.getLogger} is called from a context where\n     * there is no caller frame on the stack (e.g when called directly\n     * from a JNI attached thread), {@code IllegalCallerException} is thrown.\n     * To obtain a logger in such a context, use an auxiliary class that\n     * will implicitly be identified as the caller, or use the system {@link\n     * LoggerFinder#getLoggerFinder() LoggerFinder} to obtain a logger instead.\n     * Note that doing the latter may eagerly initialize the underlying\n     * logging system.\n     *\n     * @apiNote\n     * This method is intended to be used after the system is fully initialized.\n     * This method may trigger the immediate loading and initialization\n     * of the {@link LoggerFinder} service, which may cause issues if the\n     * Java Runtime is not ready to initialize the concrete service\n     * implementation yet.\n     * System classes which may be loaded early in the boot sequence and\n     * need to log localized messages should create a logger using\n     * {@link #getLogger(java.lang.String)} and then use the log methods that\n     * take a resource bundle as parameter.\n     *\n     * @param name    the name of the logger.\n     * @param bundle  a resource bundle.\n     * @return an instance of {@link Logger} which will use the provided\n     * resource bundle for message localization.\n     * @throws NullPointerException if {@code name} is {@code null} or\n     *         {@code bundle} is {@code null}.\n     * @throws IllegalCallerException if there is no Java caller frame on the\n     *         stack.\n     *\n     * @since 9\n     */\n    @CallerSensitive\n    public static Logger getLogger(String name, ResourceBundle bundle) {\n        final ResourceBundle rb \u003d Objects.requireNonNull(bundle);\n        Objects.requireNonNull(name);\n        final Class\u003c?\u003e caller \u003d Reflection.getCallerClass();\n        if (caller \u003d\u003d null) {\n            throw new IllegalCallerException(\"no caller frame\");\n        }\n        final SecurityManager sm \u003d System.getSecurityManager();\n        // We don\u0027t use LazyLoggers if a resource bundle is specified.\n        // Bootstrap sensitive classes in the JDK do not use resource bundles\n        // when logging. This could be revisited later, if it needs to.\n        if (sm !\u003d null) {\n            final PrivilegedAction\u003cLogger\u003e pa \u003d\n                    () -\u003e LoggerFinder.accessProvider()\n                            .getLocalizedLogger(name, rb, caller.getModule());\n            return AccessController.doPrivileged(pa, null,\n                                         LoggerFinder.LOGGERFINDER_PERMISSION);\n        }\n        return LoggerFinder.accessProvider()\n                .getLocalizedLogger(name, rb, caller.getModule());\n    }\n\n    /**\n     * Terminates the currently running Java Virtual Machine. The\n     * argument serves as a status code; by convention, a nonzero status\n     * code indicates abnormal termination.\n     * \u003cp\u003e\n     * This method calls the {@code exit} method in class\n     * {@code Runtime}. This method never returns normally.\n     * \u003cp\u003e\n     * The call {@code System.exit(n)} is effectively equivalent to\n     * the call:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * Runtime.getRuntime().exit(n)\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * @param      status   exit status.\n     * @throws  SecurityException\n     *        if a security manager exists and its {@code checkExit}\n     *        method doesn\u0027t allow exit with the specified status.\n     * @see        java.lang.Runtime#exit(int)\n     */\n    public static void exit(int status) {\n        Runtime.getRuntime().exit(status);\n    }\n\n    /**\n     * Runs the garbage collector.\n     *\n     * Calling the {@code gc} method suggests that the Java Virtual\n     * Machine expend effort toward recycling unused objects in order to\n     * make the memory they currently occupy available for quick reuse.\n     * When control returns from the method call, the Java Virtual\n     * Machine has made a best effort to reclaim space from all discarded\n     * objects.\n     * \u003cp\u003e\n     * The call {@code System.gc()} is effectively equivalent to the\n     * call:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * Runtime.getRuntime().gc()\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * @see     java.lang.Runtime#gc()\n     */\n    public static void gc() {\n        Runtime.getRuntime().gc();\n    }\n\n    /**\n     * Runs the finalization methods of any objects pending finalization.\n     *\n     * Calling this method suggests that the Java Virtual Machine expend\n     * effort toward running the {@code finalize} methods of objects\n     * that have been found to be discarded but whose {@code finalize}\n     * methods have not yet been run. When control returns from the\n     * method call, the Java Virtual Machine has made a best effort to\n     * complete all outstanding finalizations.\n     * \u003cp\u003e\n     * The call {@code System.runFinalization()} is effectively\n     * equivalent to the call:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * Runtime.getRuntime().runFinalization()\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * @see     java.lang.Runtime#runFinalization()\n     */\n    public static void runFinalization() {\n        Runtime.getRuntime().runFinalization();\n    }\n\n    /**\n     * Loads the native library specified by the filename argument.  The filename\n     * argument must be an absolute path name.\n     *\n     * If the filename argument, when stripped of any platform-specific library\n     * prefix, path, and file extension, indicates a library whose name is,\n     * for example, L, and a native library called L is statically linked\n     * with the VM, then the JNI_OnLoad_L function exported by the library\n     * is invoked rather than attempting to load a dynamic library.\n     * A filename matching the argument does not have to exist in the\n     * file system.\n     * See the \u003ca href\u003d\"{@docRoot}/../specs/jni/index.html\"\u003e JNI Specification\u003c/a\u003e\n     * for more details.\n     *\n     * Otherwise, the filename argument is mapped to a native library image in\n     * an implementation-dependent manner.\n     *\n     * \u003cp\u003e\n     * The call {@code System.load(name)} is effectively equivalent\n     * to the call:\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * Runtime.getRuntime().load(name)\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * @param      filename   the file to load.\n     * @throws     SecurityException  if a security manager exists and its\n     *             {@code checkLink} method doesn\u0027t allow\n     *             loading of the specified dynamic library\n     * @throws     UnsatisfiedLinkError  if either the filename is not an\n     *             absolute path name, the native library is not statically\n     *             linked with the VM, or the library cannot be mapped to\n     *             a native library image by the host system.\n     * @throws     NullPointerException if {@code filename} is {@code null}\n     * @see        java.lang.Runtime#load(java.lang.String)\n     * @see        java.lang.SecurityManager#checkLink(java.lang.String)\n     */\n    @CallerSensitive\n    public static void load(String filename) {\n        Runtime.getRuntime().load0(Reflection.getCallerClass(), filename);\n    }\n\n    /**\n     * Loads the native library specified by the {@code libname}\n     * argument.  The {@code libname} argument must not contain any platform\n     * specific prefix, file extension or path. If a native library\n     * called {@code libname} is statically linked with the VM, then the\n     * JNI_OnLoad_{@code libname} function exported by the library is invoked.\n     * See the \u003ca href\u003d\"{@docRoot}/../specs/jni/index.html\"\u003e JNI Specification\u003c/a\u003e\n     * for more details.\n     *\n     * Otherwise, the libname argument is loaded from a system library\n     * location and mapped to a native library image in an implementation-\n     * dependent manner.\n     * \u003cp\u003e\n     * The call {@code System.loadLibrary(name)} is effectively\n     * equivalent to the call\n     * \u003cblockquote\u003e\u003cpre\u003e\n     * Runtime.getRuntime().loadLibrary(name)\n     * \u003c/pre\u003e\u003c/blockquote\u003e\n     *\n     * @param      libname   the name of the library.\n     * @throws     SecurityException  if a security manager exists and its\n     *             {@code checkLink} method doesn\u0027t allow\n     *             loading of the specified dynamic library\n     * @throws     UnsatisfiedLinkError if either the libname argument\n     *             contains a file path, the native library is not statically\n     *             linked with the VM,  or the library cannot be mapped to a\n     *             native library image by the host system.\n     * @throws     NullPointerException if {@code libname} is {@code null}\n     * @see        java.lang.Runtime#loadLibrary(java.lang.String)\n     * @see        java.lang.SecurityManager#checkLink(java.lang.String)\n     */\n    @CallerSensitive\n    public static void loadLibrary(String libname) {\n        Runtime.getRuntime().loadLibrary0(Reflection.getCallerClass(), libname);\n    }\n\n    /**\n     * Maps a library name into a platform-specific string representing\n     * a native library.\n     *\n     * @param      libname the name of the library.\n     * @return     a platform-dependent native library name.\n     * @throws     NullPointerException if {@code libname} is {@code null}\n     * @see        java.lang.System#loadLibrary(java.lang.String)\n     * @see        java.lang.ClassLoader#findLibrary(java.lang.String)\n     * @since      1.2\n     */\n    public static native String mapLibraryName(String libname);\n\n    /**\n     * Create PrintStream for stdout/err based on encoding.\n     */\n    private static PrintStream newPrintStream(FileOutputStream fos, String enc) {\n       if (enc !\u003d null) {\n            try {\n                return new PrintStream(new BufferedOutputStream(fos, 128), true, enc);\n            } catch (UnsupportedEncodingException uee) {}\n        }\n        return new PrintStream(new BufferedOutputStream(fos, 128), true);\n    }\n\n    /**\n     * Logs an exception/error at initialization time to stdout or stderr.\n     *\n     * @param printToStderr to print to stderr rather than stdout\n     * @param printStackTrace to print the stack trace\n     * @param msg the message to print before the exception, can be {@code null}\n     * @param e the exception or error\n     */\n    private static void logInitException(boolean printToStderr,\n                                         boolean printStackTrace,\n                                         String msg,\n                                         Throwable e) {\n        if (VM.initLevel() \u003c 1) {\n            throw new InternalError(\"system classes not initialized\");\n        }\n        PrintStream log \u003d (printToStderr) ? err : out;\n        if (msg !\u003d null) {\n            log.println(msg);\n        }\n        if (printStackTrace) {\n            e.printStackTrace(log);\n        } else {\n            log.println(e);\n            for (Throwable suppressed : e.getSuppressed()) {\n                log.println(\"Suppressed: \" + suppressed);\n            }\n            Throwable cause \u003d e.getCause();\n            if (cause !\u003d null) {\n                log.println(\"Caused by: \" + cause);\n            }\n        }\n    }\n\n    /**\n     * Initialize the system class.  Called after thread initialization.\n     */\n    private static void initPhase1() {\n\n        // VM might invoke JNU_NewStringPlatform() to set those encoding\n        // sensitive properties (user.home, user.name, boot.class.path, etc.)\n        // during \"props\" initialization, in which it may need access, via\n        // System.getProperty(), to the related system encoding property that\n        // have been initialized (put into \"props\") at early stage of the\n        // initialization. So make sure the \"props\" is available at the\n        // very beginning of the initialization and all system properties to\n        // be put into it directly.\n        props \u003d new Properties(84);\n        initProperties(props);  // initialized by the VM\n\n        // There are certain system configurations that may be controlled by\n        // VM options such as the maximum amount of direct memory and\n        // Integer cache size used to support the object identity semantics\n        // of autoboxing.  Typically, the library will obtain these values\n        // from the properties set by the VM.  If the properties are for\n        // internal implementation use only, these properties should be\n        // removed from the system properties.\n        //\n        // See java.lang.Integer.IntegerCache and the\n        // VM.saveAndRemoveProperties method for example.\n        //\n        // Save a private copy of the system properties object that\n        // can only be accessed by the internal implementation.  Remove\n        // certain system properties that are not intended for public access.\n        VM.saveAndRemoveProperties(props);\n\n        lineSeparator \u003d props.getProperty(\"line.separator\");\n        StaticProperty.javaHome();          // Load StaticProperty to cache the property values\n        VersionProps.init();\n\n        FileInputStream fdIn \u003d new FileInputStream(FileDescriptor.in);\n        FileOutputStream fdOut \u003d new FileOutputStream(FileDescriptor.out);\n        FileOutputStream fdErr \u003d new FileOutputStream(FileDescriptor.err);\n        setIn0(new BufferedInputStream(fdIn));\n        setOut0(newPrintStream(fdOut, props.getProperty(\"sun.stdout.encoding\")));\n        setErr0(newPrintStream(fdErr, props.getProperty(\"sun.stderr.encoding\")));\n\n        // Setup Java signal handlers for HUP, TERM, and INT (where available).\n        Terminator.setup();\n\n        // Initialize any miscellaneous operating system settings that need to be\n        // set for the class libraries. Currently this is no-op everywhere except\n        // for Windows where the process-wide error mode is set before the java.io\n        // classes are used.\n        VM.initializeOSEnvironment();\n\n        // The main thread is not added to its thread group in the same\n        // way as other threads; we must do it ourselves here.\n        Thread current \u003d Thread.currentThread();\n        current.getThreadGroup().add(current);\n\n        // register shared secrets\n        setJavaLangAccess();\n\n        // Subsystems that are invoked during initialization can invoke\n        // VM.isBooted() in order to avoid doing things that should\n        // wait until the VM is fully initialized. The initialization level\n        // is incremented from 0 to 1 here to indicate the first phase of\n        // initialization has completed.\n        // IMPORTANT: Ensure that this remains the last initialization action!\n        VM.initLevel(1);\n    }\n\n    // @see #initPhase2()\n    static ModuleLayer bootLayer;\n\n    /*\n     * Invoked by VM.  Phase 2 module system initialization.\n     * Only classes in java.base can be loaded in this phase.\n     *\n     * @param printToStderr print exceptions to stderr rather than stdout\n     * @param printStackTrace print stack trace when exception occurs\n     *\n     * @return JNI_OK for success, JNI_ERR for failure\n     */\n    private static int initPhase2(boolean printToStderr, boolean printStackTrace) {\n        try {\n            bootLayer \u003d ModuleBootstrap.boot();\n        } catch (Exception | Error e) {\n            logInitException(printToStderr, printStackTrace,\n                             \"Error occurred during initialization of boot layer\", e);\n            return -1; // JNI_ERR\n        }\n\n        // module system initialized\n        VM.initLevel(2);\n\n        return 0; // JNI_OK\n    }\n\n    /*\n     * Invoked by VM.  Phase 3 is the final system initialization:\n     * 1. set security manager\n     * 2. set system class loader\n     * 3. set TCCL\n     *\n     * This method must be called after the module system initialization.\n     * The security manager and system class loader may be custom class from\n     * the application classpath or modulepath.\n     */\n    private static void initPhase3() {\n        // set security manager\n        String cn \u003d System.getProperty(\"java.security.manager\");\n        if (cn !\u003d null) {\n            if (cn.isEmpty() || \"default\".equals(cn)) {\n                System.setSecurityManager(new SecurityManager());\n            } else {\n                try {\n                    Class\u003c?\u003e c \u003d Class.forName(cn, false, ClassLoader.getBuiltinAppClassLoader());\n                    Constructor\u003c?\u003e ctor \u003d c.getConstructor();\n                    // Must be a public subclass of SecurityManager with\n                    // a public no-arg constructor\n                    if (!SecurityManager.class.isAssignableFrom(c) ||\n                            !Modifier.isPublic(c.getModifiers()) ||\n                            !Modifier.isPublic(ctor.getModifiers())) {\n                        throw new Error(\"Could not create SecurityManager: \" + ctor.toString());\n                    }\n                    // custom security manager implementation may be in unnamed module\n                    // or a named module but non-exported package\n                    ctor.setAccessible(true);\n                    SecurityManager sm \u003d (SecurityManager) ctor.newInstance();\n                    System.setSecurityManager(sm);\n                } catch (Exception e) {\n                    throw new Error(\"Could not create SecurityManager\", e);\n                }\n            }\n        }\n\n        // initializing the system class loader\n        VM.initLevel(3);\n\n        // system class loader initialized\n        ClassLoader scl \u003d ClassLoader.initSystemClassLoader();\n\n        // set TCCL\n        Thread.currentThread().setContextClassLoader(scl);\n\n        // system is fully initialized\n        VM.initLevel(4);\n    }\n\n    private static void setJavaLangAccess() {\n        // Allow privileged classes outside of java.lang\n        SharedSecrets.setJavaLangAccess(new JavaLangAccess() {\n            public List\u003cMethod\u003e getDeclaredPublicMethods(Class\u003c?\u003e klass, String name, Class\u003c?\u003e... parameterTypes) {\n                return klass.getDeclaredPublicMethods(name, parameterTypes);\n            }\n            public jdk.internal.reflect.ConstantPool getConstantPool(Class\u003c?\u003e klass) {\n                return klass.getConstantPool();\n            }\n            public boolean casAnnotationType(Class\u003c?\u003e klass, AnnotationType oldType, AnnotationType newType) {\n                return klass.casAnnotationType(oldType, newType);\n            }\n            public AnnotationType getAnnotationType(Class\u003c?\u003e klass) {\n                return klass.getAnnotationType();\n            }\n            public Map\u003cClass\u003c? extends Annotation\u003e, Annotation\u003e getDeclaredAnnotationMap(Class\u003c?\u003e klass) {\n                return klass.getDeclaredAnnotationMap();\n            }\n            public byte[] getRawClassAnnotations(Class\u003c?\u003e klass) {\n                return klass.getRawAnnotations();\n            }\n            public byte[] getRawClassTypeAnnotations(Class\u003c?\u003e klass) {\n                return klass.getRawTypeAnnotations();\n            }\n            public byte[] getRawExecutableTypeAnnotations(Executable executable) {\n                return Class.getExecutableTypeAnnotationBytes(executable);\n            }\n            public \u003cE extends Enum\u003cE\u003e\u003e\n            E[] getEnumConstantsShared(Class\u003cE\u003e klass) {\n                return klass.getEnumConstantsShared();\n            }\n            public void blockedOn(Interruptible b) {\n                Thread.blockedOn(b);\n            }\n            public void registerShutdownHook(int slot, boolean registerShutdownInProgress, Runnable hook) {\n                Shutdown.add(slot, registerShutdownInProgress, hook);\n            }\n            public Thread newThreadWithAcc(Runnable target, AccessControlContext acc) {\n                return new Thread(target, acc);\n            }\n            @SuppressWarnings(\"deprecation\")\n            public void invokeFinalize(Object o) throws Throwable {\n                o.finalize();\n            }\n            public ConcurrentHashMap\u003c?, ?\u003e createOrGetClassLoaderValueMap(ClassLoader cl) {\n                return cl.createOrGetClassLoaderValueMap();\n            }\n            public Class\u003c?\u003e defineClass(ClassLoader loader, String name, byte[] b, ProtectionDomain pd, String source) {\n                return ClassLoader.defineClass1(loader, name, b, 0, b.length, pd, source);\n            }\n            public Class\u003c?\u003e findBootstrapClassOrNull(ClassLoader cl, String name) {\n                return cl.findBootstrapClassOrNull(name);\n            }\n            public Package definePackage(ClassLoader cl, String name, Module module) {\n                return cl.definePackage(name, module);\n            }\n            public String fastUUID(long lsb, long msb) {\n                return Long.fastUUID(lsb, msb);\n            }\n            public void addNonExportedPackages(ModuleLayer layer) {\n                SecurityManager.addNonExportedPackages(layer);\n            }\n            public void invalidatePackageAccessCache() {\n                SecurityManager.invalidatePackageAccessCache();\n            }\n            public Module defineModule(ClassLoader loader,\n                                       ModuleDescriptor descriptor,\n                                       URI uri) {\n                return new Module(null, loader, descriptor, uri);\n            }\n            public Module defineUnnamedModule(ClassLoader loader) {\n                return new Module(loader);\n            }\n            public void addReads(Module m1, Module m2) {\n                m1.implAddReads(m2);\n            }\n            public void addReadsAllUnnamed(Module m) {\n                m.implAddReadsAllUnnamed();\n            }\n            public void addExports(Module m, String pn, Module other) {\n                m.implAddExports(pn, other);\n            }\n            public void addExportsToAllUnnamed(Module m, String pn) {\n                m.implAddExportsToAllUnnamed(pn);\n            }\n            public void addOpens(Module m, String pn, Module other) {\n                m.implAddOpens(pn, other);\n            }\n            public void addOpensToAllUnnamed(Module m, String pn) {\n                m.implAddOpensToAllUnnamed(pn);\n            }\n            public void addOpensToAllUnnamed(Module m, Iterator\u003cString\u003e packages) {\n                m.implAddOpensToAllUnnamed(packages);\n            }\n            public void addUses(Module m, Class\u003c?\u003e service) {\n                m.implAddUses(service);\n            }\n            public boolean isReflectivelyExported(Module m, String pn, Module other) {\n                return m.isReflectivelyExported(pn, other);\n            }\n            public boolean isReflectivelyOpened(Module m, String pn, Module other) {\n                return m.isReflectivelyOpened(pn, other);\n            }\n            public ServicesCatalog getServicesCatalog(ModuleLayer layer) {\n                return layer.getServicesCatalog();\n            }\n            public Stream\u003cModuleLayer\u003e layers(ModuleLayer layer) {\n                return layer.layers();\n            }\n            public Stream\u003cModuleLayer\u003e layers(ClassLoader loader) {\n                return ModuleLayer.layers(loader);\n            }\n\n            public String newStringNoRepl(byte[] bytes, Charset cs) throws CharacterCodingException  {\n                return StringCoding.newStringNoRepl(bytes, cs);\n            }\n\n            public byte[] getBytesNoRepl(String s, Charset cs) throws CharacterCodingException {\n                return StringCoding.getBytesNoRepl(s, cs);\n            }\n\n            public String newStringUTF8NoRepl(byte[] bytes, int off, int len) {\n                return StringCoding.newStringUTF8NoRepl(bytes, off, len);\n            }\n\n            public byte[] getBytesUTF8NoRepl(String s) {\n                return StringCoding.getBytesUTF8NoRepl(s);\n            }\n\n        });\n    }\n}\n"
    }
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.base/java.lang.Thread.run(Thread.java:834)
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.nio.file.FileSystemNotFoundException: /Users/georgy/Library/Caches/Coursier/arc/https/github.com/AdoptOpenJDK/openjdk11-binaries/releases/download/jdk-11%2B28/OpenJDK11-jdk_x64_mac_hotspot_11_28.tar.gz/jdk-11+28/Contents/Home/lib/src.zip
	at jdk.zipfs/jdk.nio.zipfs.ZipFileSystem.<init>(ZipFileSystem.java:104)
	at jdk.zipfs/jdk.nio.zipfs.ZipFileSystemProvider.newFileSystem(ZipFileSystemProvider.java:106)
	at java.base/java.nio.file.FileSystems.newFileSystem(FileSystems.java:344)
	at java.base/java.nio.file.FileSystems.newFileSystem(FileSystems.java:293)
	at scala.meta.internal.io.PlatformFileIO$.newFileSystem(PlatformFileIO.scala:104)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionURIMtags.toAbsolutePath(MtagsEnrichments.scala:112)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:139)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:137)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:609)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:606)
	at scala.meta.internal.metals.MetalsLanguageServer.didOpen(MetalsLanguageServer.scala:1077)
	... 16 more

окт. 07, 2022 11:31:58 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didClose",
  "params": {
    "textDocument": {
      "uri": "jar:file%3A///Users/georgy/Library/Caches/Coursier/arc/https/github.com/AdoptOpenJDK/openjdk11-binaries/releases/download/jdk-11%25252B28/OpenJDK11-jdk_x64_mac_hotspot_11_28.tar.gz/jdk-11%2B28/Contents/Home/lib/src.zip%21/java.base/java/lang/System.java"
    }
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.base/java.lang.Thread.run(Thread.java:834)
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.nio.file.FileSystemNotFoundException: /Users/georgy/Library/Caches/Coursier/arc/https/github.com/AdoptOpenJDK/openjdk11-binaries/releases/download/jdk-11%2B28/OpenJDK11-jdk_x64_mac_hotspot_11_28.tar.gz/jdk-11+28/Contents/Home/lib/src.zip
	at jdk.zipfs/jdk.nio.zipfs.ZipFileSystem.<init>(ZipFileSystem.java:104)
	at jdk.zipfs/jdk.nio.zipfs.ZipFileSystemProvider.newFileSystem(ZipFileSystemProvider.java:106)
	at java.base/java.nio.file.FileSystems.newFileSystem(FileSystems.java:344)
	at java.base/java.nio.file.FileSystems.newFileSystem(FileSystems.java:293)
	at scala.meta.internal.io.PlatformFileIO$.newFileSystem(PlatformFileIO.scala:104)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionURIMtags.toAbsolutePath(MtagsEnrichments.scala:112)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:139)
	at scala.meta.internal.mtags.MtagsEnrichments$XtensionStringMtags.toAbsolutePath(MtagsEnrichments.scala:137)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:609)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:606)
	at scala.meta.internal.metals.MetalsLanguageServer.didClose(MetalsLanguageServer.scala:1253)
	... 16 more

2022.10.07 11:31:59 WARN  no build target for: /Users/georgy/Desktop/study/vii-semester/diploma/explore/src/main/scala/navigate/Main.scala
2022.10.07 11:33:45 WARN  no build target for: /Users/georgy/Desktop/study/vii-semester/diploma/explore/src/main/scala/navigate/MisisB.scala
2022.10.07 11:54:20 WARN  no build target for: /Users/georgy/Desktop/study/vii-semester/diploma/explore/src/main/scala/navigate/Graph.scala
2022.10.07 11:54:22 WARN  no build target for: /Users/georgy/Desktop/study/vii-semester/diploma/explore/src/main/scala/navigate/MisisB.scala
2022.10.07 11:54:23 WARN  no build target for: /Users/georgy/Desktop/study/vii-semester/diploma/explore/src/main/scala/navigate/Graph.scala
2022.10.10 17:34:34 INFO  shutting down Metals
2022.10.11 01:47:39 INFO  tracing is disabled for protocol LSP, to enable tracing of incoming and outgoing JSON messages create an empty file at /Users/georgy/Desktop/study/vii-semester/diploma/explore/.metals/lsp.trace.json or /Users/georgy/Library/Caches/org.scalameta.metals/lsp.trace.json
2022.10.11 01:47:40 INFO  logging to file /Users/georgy/Desktop/study/vii-semester/diploma/explore/.metals/metals.log
2022.10.11 01:47:40 INFO  Started: Metals version 0.11.9 in workspace '/Users/georgy/Desktop/study/vii-semester/diploma/explore' for client Visual Studio Code 1.72.0.
2022.10.11 01:47:41 INFO  time: initialize in 1.62s
2022.10.11 01:47:43 WARN  Build server is not auto-connectable.
2022.10.11 01:47:43 WARN  no build target for: /Users/georgy/Desktop/study/vii-semester/diploma/explore/src/main/scala/navigate/Graph.scala
2022.10.11 01:47:43 WARN  no build target for: /Users/georgy/Desktop/study/vii-semester/diploma/explore/src/main/scala/navigate/Main.scala
2022.10.11 01:47:46 INFO  no build target found for /Users/georgy/Desktop/study/vii-semester/diploma/explore/src/main/scala/navigate/Graph.scala. Using presentation compiler with project's scala-library version: 3.2.0
2022.10.11 01:47:49 INFO  time: code lens generation in 5.93s
2022.10.11 01:47:53 INFO  shutting down Metals
2022.10.11 01:47:53 ERROR Unexpected error initializing serverorg.eclipse.lsp4j.jsonrpc.ResponseErrorException: Request window/showMessageRequest failed with message: Canceled
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleResponse(RemoteEndpoint.java:209)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:193)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.lang.Thread.run(Thread.java:834)

2022.10.11 13:17:45 INFO  tracing is disabled for protocol LSP, to enable tracing of incoming and outgoing JSON messages create an empty file at /Users/georgy/Desktop/study/vii-semester/diploma/explore/.metals/lsp.trace.json or /Users/georgy/Library/Caches/org.scalameta.metals/lsp.trace.json
2022.10.11 13:17:46 INFO  logging to file /Users/georgy/Desktop/study/vii-semester/diploma/explore/.metals/metals.log
2022.10.11 13:17:46 INFO  Started: Metals version 0.11.9 in workspace '/Users/georgy/Desktop/study/vii-semester/diploma/explore' for client Visual Studio Code 1.72.0.
2022.10.11 13:17:47 INFO  time: initialize in 1.61s
2022.10.11 13:17:50 WARN  Build server is not auto-connectable.
2022.10.11 13:17:50 WARN  no build target for: /Users/georgy/Desktop/study/vii-semester/diploma/explore/src/main/scala/navigate/Graph.scala
2022.10.11 13:17:54 INFO  no build target found for /Users/georgy/Desktop/study/vii-semester/diploma/explore/src/main/scala/navigate/Graph.scala. Using presentation compiler with project's scala-library version: 3.2.0
2022.10.11 13:17:57 INFO  time: code lens generation in 7.28s
2022.10.11 13:21:24 INFO  shutting down Metals
2022.10.12 20:59:47 INFO  tracing is disabled for protocol LSP, to enable tracing of incoming and outgoing JSON messages create an empty file at /Users/georgy/Desktop/study/vii-semester/diploma/explore/.metals/lsp.trace.json or /Users/georgy/Library/Caches/org.scalameta.metals/lsp.trace.json
2022.10.12 20:59:47 INFO  logging to file /Users/georgy/Desktop/study/vii-semester/diploma/explore/.metals/metals.log
2022.10.12 20:59:47 INFO  Started: Metals version 0.11.9 in workspace '/Users/georgy/Desktop/study/vii-semester/diploma/explore' for client Visual Studio Code 1.72.1.
2022.10.12 20:59:49 INFO  time: initialize in 1.71s
2022.10.12 20:59:51 WARN  Build server is not auto-connectable.
2022.10.12 20:59:51 WARN  no build target for: /Users/georgy/Desktop/study/vii-semester/diploma/explore/src/main/scala/navigate/Graph.scala
2022.10.12 20:59:55 INFO  no build target found for /Users/georgy/Desktop/study/vii-semester/diploma/explore/src/main/scala/navigate/Graph.scala. Using presentation compiler with project's scala-library version: 3.2.0
2022.10.12 20:59:56 WARN  no build target for: /Users/georgy/Desktop/study/vii-semester/diploma/explore/src/main/scala/navigate/Main.scala
окт. 12, 2022 8:59:56 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 5
2022.10.12 20:59:56 INFO  shutting down Metals
java.util.concurrent.RejectedExecutionException: Task Future(<not completed>) rejected from java.util.concurrent.ThreadPoolExecutor@1b402b23[Shutting down, pool size = 4, active threads = 4, queued tasks = 0, completed tasks = 235]
	at java.base/java.util.concurrent.ThreadPoolExecutor$AbortPolicy.rejectedExecution(ThreadPoolExecutor.java:2055)
	at java.base/java.util.concurrent.ThreadPoolExecutor.reject(ThreadPoolExecutor.java:825)
	at java.base/java.util.concurrent.ThreadPoolExecutor.execute(ThreadPoolExecutor.java:1355)
	at scala.concurrent.impl.ExecutionContextImpl.execute(ExecutionContextImpl.scala:21)
	at scala.concurrent.impl.Promise$Transformation.submitWithValue(Promise.scala:429)
	at scala.concurrent.impl.Promise$DefaultPromise.submitWithValue(Promise.scala:338)
	at scala.concurrent.impl.Promise$DefaultPromise.tryComplete0(Promise.scala:285)
	at scala.concurrent.impl.Promise$Transformation.handleFailure(Promise.scala:444)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:506)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.base/java.lang.Thread.run(Thread.java:834)
java.util.concurrent.RejectedExecutionException: Task Future(<not completed>) rejected from java.util.concurrent.ThreadPoolExecutor@1b402b23[Shutting down, pool size = 3, active threads = 3, queued tasks = 0, completed tasks = 236]
	at java.base/java.util.concurrent.ThreadPoolExecutor$AbortPolicy.rejectedExecution(ThreadPoolExecutor.java:2055)
	at java.base/java.util.concurrent.ThreadPoolExecutor.reject(ThreadPoolExecutor.java:825)
	at java.base/java.util.concurrent.ThreadPoolExecutor.execute(ThreadPoolExecutor.java:1355)
	at scala.concurrent.impl.ExecutionContextImpl.execute(ExecutionContextImpl.scala:21)
	at scala.concurrent.impl.Promise$Transformation.submitWithValue(Promise.scala:429)
	at scala.concurrent.impl.Promise$DefaultPromise.submitWithValue(Promise.scala:338)
	at scala.concurrent.impl.Promise$DefaultPromise.tryComplete0(Promise.scala:285)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:504)2022.10.12 20:59:59 ERROR Unexpected error initializing serverorg.eclipse.lsp4j.jsonrpc.ResponseErrorException: Request window/showMessageRequest failed with message: Canceled
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleResponse(RemoteEndpoint.java:209)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:193)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.lang.Thread.run(Thread.java:834)


	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.base/java.lang.Thread.run(Thread.java:834)
2022.10.12 20:59:59 WARN  sql closed: select build_target_uri from dependency_source where text_document_uri = ?;
2022.10.12 20:59:59 WARN  sql closed: select worksheet_uri from worksheet_dependency_source where text_document_uri = ?;
java.util.concurrent.RejectedExecutionException: Task Future(<not completed>) rejected from java.util.concurrent.ThreadPoolExecutor@1b402b23[Shutting down, pool size = 1, active threads = 1, queued tasks = 0, completed tasks = 238]
	at java.base/java.util.concurrent.ThreadPoolExecutor$AbortPolicy.rejectedExecution(ThreadPoolExecutor.java:2055)
	at java.base/java.util.concurrent.ThreadPoolExecutor.reject(ThreadPoolExecutor.java:825)
	at java.base/java.util.concurrent.ThreadPoolExecutor.execute(ThreadPoolExecutor.java:1355)
	at scala.concurrent.impl.ExecutionContextImpl.execute(ExecutionContextImpl.scala:21)
	at scala.concurrent.impl.Promise$Transformation.submitWithValue(Promise.scala:429)
	at scala.concurrent.impl.Promise$DefaultPromise.submitWithValue(Promise.scala:338)
	at scala.concurrent.impl.Promise$DefaultPromise.tryComplete0(Promise.scala:285)
	at scala.concurrent.impl.Promise$Transformation.handleFailure(Promise.scala:444)
	at scala.concurrent.impl.Promise$Transformation.run(Promise.scala:506)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.base/java.lang.Thread.run(Thread.java:834)
